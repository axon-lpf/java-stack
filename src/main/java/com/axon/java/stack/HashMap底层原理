1. HashMap 的基本结构

	•	HashMap 是基于 数组 + 链表（Java 8 之后加入了红黑树） 的数据结构。
	•	底层维护了一个数组，数组的每个元素都是一个 链表节点 或 红黑树节点。
	•	默认情况下，HashMap 的初始容量为 16，负载因子为 0.75，也就是说，当 HashMap 的使用容量达到初始容量的 75% 时，HashMap 会进行 扩容。

2. 键值对的存储

	•	当我们向 HashMap 插入一个键值对时，首先根据键的 hashCode() 方法计算出一个 hash 值，通过 (n - 1) & hash 计算得到该键值对在数组中的位置（n 是数组的长度）。
	•	如果该位置为空，就将该键值对直接存储在该位置。如果不为空，说明发生了哈希冲突，则会将新键值对添加到链表的末尾（Java 8 之前）或处理为红黑树结构（当链表长度超过 8 时）。

3. 解决哈希冲突

	•	链表法（拉链法）：在相同数组索引位置上，HashMap 通过链表将多个冲突的键值对串联起来。当链表长度超过 8 且数组大小超过 64 时，链表会转换为 红黑树 来提高查找效率。
	•	树化机制：Java 8 引入了红黑树，当链表的长度超过 8 时，会将链表转换为红黑树，以保证在极端情况下仍然能保持 O(log n) 的查询性能。

4. 扩容机制

	•	HashMap 的默认负载因子是 0.75。当 HashMap 的元素数量超过 当前容量 × 负载因子 时，HashMap 就会触发扩容，将数组的长度扩展为当前容量的两倍。
	•	扩容过程中，HashMap 会将原有的元素重新计算哈希值，并放入新的数组中（rehash），这时由于扩容为两倍，所以很多元素可能会被分散到不同的位置。

5. 线程不安全问题

	•	HashMap 不是线程安全的。如果多个线程同时对 HashMap 进行操作，可能会导致 死循环 或 数据丢失 等问题。针对并发场景，可以使用 ConcurrentHashMap 或通过外部同步机制来保证线程安全。

6. 读取与写入的效率

	•	理论上，HashMap 的 查找、插入和删除 操作的时间复杂度是 O(1)，但在最坏的情况下（所有键值对都分配到了相同的数组位置，链表极长），时间复杂度可能会降到 O(n)。通过引入红黑树，Java 8 之后可以将最坏情况下的查找效率优化为 O(log n)。

7. 重要的细节

	•	resize 时，旧数组的内容并不会重新计算哈希值，而是通过新的数组容量进行位置重新分配。
	•	Null 键和值：HashMap 允许 null 键 和 null 值。Null 键总是存储在数组的第一个位置。
	•	fail-fast 机制：在使用迭代器遍历 HashMap 的过程中，如果有其他线程对 HashMap 进行了结构性修改，会抛出 ConcurrentModificationException。

示例图解

	•	HashMap 结构图：
	        +---+---+---+---+---+---+---+---+---+---+
            |   |   |   | H |   |   |   |   |   |   |  <-- 数组
            +---+---+---+---+---+---+---+---+---+---+
                        |
                        v
                   +---------+    +---------+    +---------+
                   | Entry 1 | -> | Entry 2 | -> | Entry 3 |
                   +---------+    +---------+    +---------+

扩容扩的是哈系桶，即数组的长度。 hashMap 元素总和达到0.75    即16*075=12个

回答总结：

	HashMap 是一种基于数组加链表/红黑树的哈希表实现，存储时根据键的 hashCode 计算哈希值来确定数组索引。通过拉链法解决哈希冲突，Java 8 引入了红黑树来优化链表性能。当元素数量达到容量的 75% 时，HashMap 会自动扩容，扩容时重新分配元素。
它不是线程安全的，需要在并发场景下使用其他替代方案。



时间复杂度的说明:

时间复杂度是衡量算法在最坏情况下执行时间增长率的一个指标，它表示随着输入数据规模（n）的增大，算法执行时间的增长情况。

	•	O：表示算法的复杂度（时间或空间）。这是 “Big O” 表示法，描述了随着输入规模增大，算法的性能增长趋势。
	•	n：通常代表问题的输入规模（例如，输入数据的元素个数）。

常见的时间复杂度

	1.	O(1)：常数时间复杂度，算法的执行时间不随输入规模的增长而变化，比如访问数组的某个元素。
	2.	O(n)：线性时间复杂度，算法的执行时间随着输入规模 n 成正比地增长。例如，遍历一个包含 n 个元素的数组需要执行 n 次操作。
	3.	O(n²)：平方时间复杂度，算法的执行时间随着输入规模 n 成平方关系地增长，比如双重嵌套循环。
	4.	O(log n)：对数时间复杂度，执行时间随着输入规模的增长而较慢地增加，比如二分查找。
