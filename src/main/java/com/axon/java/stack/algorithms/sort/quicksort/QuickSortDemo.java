package com.axon.java.stack.algorithms.sort.quicksort;

import java.util.Arrays;

/**
 * 快速排序
 * 思路： 快速排序，找一个中间值， 大于中间值的排在右边， 小于中间值的，则排序在左边， 然后再排序
 * 例如： arr = {-9, 78, 0, 23, -576, 70};
 *
 * 我们可以通过一个具体的例子逐步跟踪递归的过程，以帮助理解递归时“向左边递归”和“向右边递归”的含义。以下是代码应用于示例数组 arr = {-9, 78, 0, 23, -576, 70} 时的逐步解释。
 * arr = {-9, 78, 0, 23, -576, 70}
 *
 * 第一层递归：
 *
 * 	1.	初始调用：quickSort(arr, 0, 5)，即 left = 0，right = 5，数组的左右边界分别是第一个和最后一个元素。
 * 	2.	计算基准索引 point = (0 + 5) / 2 = 2，基准值为 arr[2] = 0。
 * 	3.	我们会找到一个左侧比基准值大的元素和右侧比基准值小的元素，然后交换它们的位置。
 *
 * 第一次交换：
 *
 * 	•	左指针 l 从 0 开始，直到位置 1 遇到 78，大于基准值 0，停下。
 * 	•	右指针 r 从 5 开始，直到位置 4 遇到 -576，小于基准值 0，停下。
 * 	•	交换 arr[1] 和 arr[4] 后，数组变为：arr = {-9, -576, 0, 23, 78, 70}
 * 	    继续移动指针：
 *
 * 	•	左指针 l 从 1 开始继续移动到 2，到达基准值 0。
 * 	•	右指针 r 从 4 开始继续移动到 2，也到达基准值 0。
 * 	•	此时 l >= r，结束第一层的 while 循环。
 *
 * 划分左右部分并递归：
 *
 * 	•	左部分：索引范围为 [0, 1]，即 left = 0，r = 1。
 * 	•	右部分：索引范围为 [3, 5]，即 l = 3，right = 5。
 * 	•	对左部分调用 quickSort(arr, 0, 1)，对右部分调用 quickSort(arr, 3, 5)。
 *
 *
 * 第二层递归（左部分 quickSort(arr, 0, 1)）：
 *
 * 	1.	当前 arr = {-9, -576, 0, 23, 78, 70}。
 * 	2.	对 [0, 1] 的数组范围进行处理，基准索引 point = (0 + 1) / 2 = 0，基准值为 -9。
 * 	3.	左指针 l 停在位置 0，右指针 r 停在位置 1。
 * 	4.	交换 arr[0] 和 arr[1] 后，数组变为：arr = {-576, -9, 0, 23, 78, 70}
 * 	    划分左右部分并递归：
 *
 * 	•	此时 l > r，分割完成，继续递归。
 * 	•	新的左部分 quickSort(arr, 0, -1) 和右部分 quickSort(arr, 1, 1) 不满足 left < r 和 right > l 条件，递归结束。
 *
 * 	第二层递归（右部分 quickSort(arr, 3, 5)）：
 *
 * 	1.	当前 arr = {-576, -9, 0, 23, 78, 70}。
 * 	2.	对 [3, 5] 的数组范围进行处理，基准索引 point = (3 + 5) / 2 = 4，基准值为 78。
 * 	3.	左指针 l 停在位置 3，右指针 r 停在位置 5。
 * 	4.	交换 arr[3] 和 arr[5] 后，数组变为：arr = {-576, -9, 0, 70, 23, 78}
 *
 * 	    划分左右部分并递归：
 *
 * 	•	左部分：quickSort(arr, 3, 4)。
 * 	•	右部分：quickSort(arr, 5, 5)，满足 right <= l 条件，递归结束。
 *
 * 第三层递归（左部分 quickSort(arr, 3, 4)）：
 *
 * 	1.	当前 arr = {-576, -9, 0, 23, 70, 78}。
 * 	2.	对 [3, 4] 范围处理，基准索引 point = 3，基准值 23。
 * 	3.	左指针和右指针都指向 3。
 * 	4.	递归终止。
 *
 * 最终结果是 arr = {-576, -9, 0, 23, 70, 78}
 *
 *
 *
 */
public class QuickSortDemo {
    public static void main(String[] args) {

        int[] arr = {-9, 78, 0, 23, -576, 70};
        quickSort(arr, 0, arr.length - 1);
        System.out.println(Arrays.toString(arr));
    }

    public static void quickSort(int[] arr, int left, int right) {

        int point = (left + right) / 2;
        int l = left, r = right;
        int temp;
        /**
         *  如果小于l<r，则说明没有处理完成
         */
        while (l < r) {
            //如果左边的值，一直小于中间值，则继续找，找到大于中间值的为止
            while (arr[l] < arr[point]) {
                l += 1;
            }
            // 如果右边的值，一直大于中间的值，则继续找，则找到小于中间的值为止
            while (arr[r] > arr[point]) {
                r -= 1;
            }

            // 如果l >r 则说明已经找完了，结束循环
            if (l >= r) {
                break;
            }
            //进行交换赋值 ,将左边的值赋值给临时变量
            temp = arr[l];
            // 将右边的值，赋值给左边的值，
            arr[l] = arr[r];
            // 将左边的值赋值给中间值的右边
            arr[r] = temp;


            // 如果交换后的值，等与中间值相等， 则继续+1
            if (arr[r] == arr[point]) {
                l += 1;
            }
            // 如果交换后的值，等与中间值相等， 则继续-11
            if (arr[l] == arr[point]) {
                r -= 1;
            }

        }

        // 此时这里说明位置已经交错在一块了， 为了避免死归， 这里需要左右各加1
        if (l == r) {
            l += 1;
            r -= 1;
        }

        // 向左边递归
        if (left < r) {
            quickSort(arr, left, r);
        }

        //向右边递归
        if (right > l) {
            quickSort(arr, l, right);
        }

    }
}
