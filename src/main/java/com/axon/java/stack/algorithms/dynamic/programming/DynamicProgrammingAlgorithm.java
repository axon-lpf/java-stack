package com.axon.java.stack.algorithms.dynamic.programming;

/**
 *  动态规划算法
 *
 *  背包问题解决思路:
 *  背包问题是动态规划的经典案例，图解能更直观地展示其计算过程。以下以0/1 背包问题为例，通过图表和表格逐步说明其计算过程。
 *
 *  问题描述
 *
 * 输入：
 * 	•	物品重量： weights = {2, 3, 4, 5}
 * 	•	物品价值： values = {3, 4, 5, 6}
 * 	•	背包容量： capacity = 8
 *
 * 目标：
 * 在不超过背包容量的前提下，选择物品使总价值最大。
 *
 * 动态规划表的构造
 *
 * 我们构建一个二维动态规划表  dp[i][j] ，其中：
 * 	•	 i  表示前  i  个物品。
 * 	•	 j  表示当前背包容量。
 *
 * 表格初始化
 *
 * 	•	**行数：**物品数量 + 1（考虑到第 0 行代表没有物品）。
 * 	•	**列数：**背包容量 + 1（容量从 0 到  C ）。
 * 	•	初始值： dp[0][j] = 0 （没有物品时，价值为 0）。
 *
 * 物品数\容量	0	1	2	3	4	5	6	7	8
 *      0	    0	0	0	0	0	0	0	0	0
 *      1
 *      2
 *      3
 *      4
 *
 * 填表过程
 *
 * 逐步计算每个  dp[i][j]  的值，遵循状态转移方程：
 *
 * 核心公式
 * dp[i][j]= dp[i-1][j]
 *           max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])
 *           j<w[i]
 *           j>=w[i]
 *
 * 步骤 1：处理物品 1
 *
 * 物品 1：重量  w[1] = 2 ，价值  v[1] = 3 。
 * 	•	背包容量  j = 0  到  1 ：装不下物品 1， dp[1][j] = dp[0][j] 。
 * 	•	背包容量  j >=2 ：可以装下物品 1，价值更新为  dp[1][j] = max(dp[0][j], dp[0][j-2] + 3) 。
 *
 * 结果表：
 * 物品数\容量	0	1	2	3	4	5	6	7	8
 *      0	    0	0	0	0	0	0	0	0	0
 *      1       0   0   3   3   3   3   3   3   3
 *      2
 *      3
 *      4
 *
 * 步骤 2：处理物品 2
 *
 * 物品 2：重量  w[2] = 3 ，价值  v[2] = 4 。
 * 	•	背包容量  j = 0  到  2 ：装不下物品 2， dp[2][j] = dp[1][j] 。
 * 	•	背包容量  j>= 3 ：可以装下物品 2，价值更新为  dp[2][j] = max(dp[1][j], dp[1][j-3] + 4) 。
 *
 * 结果表：
 * 物品数\容量	0	1	2	3	4	5	6	7	8
 *      0	    0	0	0	0	0	0	0	0	0
 *      1       0   0   3   3   3   3   3   3   3
 *      2       0   0   3   4   4   7   7   7   7
 *      3
 *      4
 *
 *步骤 3：处理物品 3
 *
 * 物品 3：重量  w[3] = 4 ，价值  v[3] = 5 。
 * 	•	背包容量  j = 0  到  3 ：装不下物品 3， dp[3][j] = dp[2][j] 。
 * 	•	背包容量  j>= 4 ：可以装下物品 3，价值更新为  dp[3][j] = max(dp[2][j], dp[2][j-4] + 5) 。
 *
 * 结果表：
 * 物品数\容量	0	1	2	3	4	5	6	7	8
 *      0	    0	0	0	0	0	0	0	0	0
 *      1       0   0   3   3   3   3   3   3   3
 *      2       0   0   3   4   4   7   7   7   7
 *      3       0   0   3   4   5   7   8   9   9
 *      4
 *
 *
 步骤 4：处理物品 4
 物品 4：重量  w[4] = 5 ，价值  v[4] = 6 。
 •	背包容量  j = 0  到  4 ：装不下物品 4， dp[4][j] = dp[3][j] 。
 •	背包容量  j >= 5 ：可以装下物品 4，价值更新为  dp[4][j] = max(dp[3][j], dp[3][j-5] + 6) 。

 最终结果表：

 * 物品数\容量	0	1	2	3	4	5	6	7	8
 *      0	    0	0	0	0	0	0	0	0	0
 *      1       0   0   3   3   3   3   3   3   3
 *      2       0   0   3   4   4   7   7   7   7
 *      3       0   0   3   4   5   7   8   9   9
 *      4       0   0   3   4   5   7   8   9   12
 *

 */
public class DynamicProgrammingAlgorithm {

    public static void main(String[] args) {
        int []	weights = {2, 3, 4, 5} ;
	    int [] values = {3, 4, 5, 6};
	    int capacity = 8;
        knapsack(weights,values,capacity);
    }


    public static int knapsack(int[] weights, int[] values, int capacity) {
        int n = weights.length;
        int[][] dp = new int[n + 1][capacity + 1];

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= capacity; j++) {
                if (j < weights[i - 1]) {
                    dp[i][j] = dp[i - 1][j]; // 容量不足，不能选
                } else {
                   int  x=  dp[i - 1][j];
                   int y= dp[i - 1][j - weights[i - 1]];
                   int value=values[i - 1];
                    dp[i][j] = Math.max(x,y + value); // 选或不选
                }
            }
        }
        return dp[n][capacity];
    }
}
