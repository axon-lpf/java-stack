这个快速排序算法的实现利用了分治的思想，通过递归地将数组分成两个部分：左边部分小于选定的中间值，右边部分大于中间值。补充说明如下：

	1.	选定基准点
	•	算法首先在 quickSort 方法中计算基准点 point，基准点是数组的中间元素，即 (left + right) / 2 位置的元素。这个值作为比较的基准，帮助我们将小于基准的元素放在其左侧，大于基准的放在右侧。
	2.	左右指针的初始化
	•	使用两个指针 l 和 r 分别从数组的左侧（left）和右侧（right）开始，找到不满足排序要求的元素进行交换。
	3.	左右指针的自旋与交换
	•	左指针 l 向右移动，寻找大于基准点的值；右指针 r 向左移动，寻找小于基准点的值。
	•	一旦找到一对不满足条件的元素，进行交换，使得左边的元素小于基准，右边的元素大于基准。
	•	通过自旋（循环）来实现排序，直到 l 和 r 相遇。
	4.	判断终止条件
	•	在自旋过程中，当 l 和 r 相遇或交错时（即 l >= r），说明当前数组部分的分区工作完成，跳出循环。
	5.	递归处理
	•	如果 l == r，说明指针已经交错，此时需要移动 l 和 r，避免递归时出现无限循环。
	•	随后，分别递归调用 quickSort 方法，对左右两部分进行同样的处理。左侧部分范围是 [left, r]，右侧部分范围是 [l, right]。
	6.	边界条件
	•	在递归中，检查 left < r 和 right > l，确保只在有多于一个元素的部分递归调用 quickSort，从而避免单元素的部分重复调用导致栈溢出。

最终，这种算法不断递归地缩小处理的范围，直到数组每个部分都有序，从而完成整个排序。