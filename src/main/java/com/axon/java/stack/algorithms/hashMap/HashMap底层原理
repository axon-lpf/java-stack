1. HashMap 的基本结构

	•	HashMap 是基于 数组 + 链表（Java 8 之后加入了红黑树） 的数据结构。
	•	底层维护了一个数组，数组的每个元素都是一个 链表节点 或 红黑树节点。
	•	默认情况下，HashMap 的初始容量为 16，负载因子为 0.75，也就是说，当 HashMap 的使用容量达到初始容量的 75% 时，HashMap 会进行 扩容。

2. 键值对的存储

	•	当我们向 HashMap 插入一个键值对时，首先根据键的 hashCode() 方法计算出一个 hash 值，通过 (n - 1) & hash 计算得到该键值对在数组中的位置（n 是数组的长度）。
	•	如果该位置为空，就将该键值对直接存储在该位置。如果不为空，说明发生了哈希冲突，则会将新键值对添加到链表的末尾（Java 8 之前）或处理为红黑树结构（当链表长度超过 8 时）。

3. 解决哈希冲突

	•	链表法（拉链法）：在相同数组索引位置上，HashMap 通过链表将多个冲突的键值对串联起来。当链表长度超过 8 且数组大小超过 64 时，链表会转换为 红黑树 来提高查找效率。
	•	树化机制：Java 8 引入了红黑树，当链表的长度超过 8 时，会将链表转换为红黑树，以保证在极端情况下仍然能保持 O(log n) 的查询性能。

4. 扩容机制

	•	HashMap 的默认负载因子是 0.75。当 HashMap 的元素数量超过 当前容量 × 负载因子 时，HashMap 就会触发扩容，将数组的长度扩展为当前容量的两倍。
	•	扩容过程中，HashMap 会将原有的元素重新计算哈希值，并放入新的数组中（rehash），这时由于扩容为两倍，所以很多元素可能会被分散到不同的位置。

5. 线程不安全问题

	•	HashMap 不是线程安全的。如果多个线程同时对 HashMap 进行操作，可能会导致 死循环 或 数据丢失 等问题。针对并发场景，可以使用 ConcurrentHashMap 或通过外部同步机制来保证线程安全。

6. 读取与写入的效率

	•	理论上，HashMap 的 查找、插入和删除 操作的时间复杂度是 O(1)，但在最坏的情况下（所有键值对都分配到了相同的数组位置，链表极长），时间复杂度可能会降到 O(n)。通过引入红黑树，Java 8 之后可以将最坏情况下的查找效率优化为 O(log n)。

7. 重要的细节

	•	resize 时，旧数组的内容并不会重新计算哈希值，而是通过新的数组容量进行位置重新分配。
	•	Null 键和值：HashMap 允许 null 键 和 null 值。Null 键总是存储在数组的第一个位置。
	•	fail-fast 机制：在使用迭代器遍历 HashMap 的过程中，如果有其他线程对 HashMap 进行了结构性修改，会抛出 ConcurrentModificationException。

示例图解

	•	HashMap 结构图：
	        +---+---+---+---+---+---+---+---+---+---+
            |   |   |   | H |   |   |   |   |   |   |  <-- 数组
            +---+---+---+---+---+---+---+---+---+---+
                        |
                        v
                   +---------+    +---------+    +---------+
                   | Entry 1 | -> | Entry 2 | -> | Entry 3 |
                   +---------+    +---------+    +---------+

扩容扩的是哈系桶，即数组的长度。 hashMap 元素总和达到0.75    即16*075=12个

回答总结：

	HashMap 是一种基于数组加链表/红黑树的哈希表实现，存储时根据键的 hashCode 计算哈希值来确定数组索引。通过拉链法解决哈希冲突，Java 8 引入了红黑树来优化链表性能。当元素数量达到容量的 75% 时，HashMap 会自动扩容，扩容时重新分配元素。
它不是线程安全的，需要在并发场景下使用其他替代方案。



时间复杂度的说明:

时间复杂度是衡量算法在最坏情况下执行时间增长率的一个指标，它表示随着输入数据规模（n）的增大，算法执行时间的增长情况。

	•	O：表示算法的复杂度（时间或空间）。这是 “Big O” 表示法，描述了随着输入规模增大，算法的性能增长趋势。
	•	n：通常代表问题的输入规模（例如，输入数据的元素个数）。

常见的时间复杂度

	1.	O(1)：常数时间复杂度，算法的执行时间不随输入规模的增长而变化，比如访问数组的某个元素。
	2.	O(n)：线性时间复杂度，算法的执行时间随着输入规模 n 成正比地增长。例如，遍历一个包含 n 个元素的数组需要执行 n 次操作。
	3.	O(n²)：平方时间复杂度，算法的执行时间随着输入规模 n 成平方关系地增长，比如双重嵌套循环。
	4.	O(log n)：对数时间复杂度，执行时间随着输入规模的增长而较慢地增加，比如二分查找。


在hasMap中 链表转换为红黑树？ 为啥不一直用链表，反而用红黑树？ 红黑树相比链表的优点在哪里？


    在 HashMap 中，当某个桶（bucket）中的元素数量超过一定阈值（通常为 8），链表会转换为红黑树，这是为了提高查找和操作效率。下面详细解释为什么不一直使用链表，而是转换为红黑树，以及红黑树相比链表的优点。

    1. 链表与红黑树的查找效率

    	•	链表：链表的查找是线性查找，时间复杂度为 O(n)，其中 n 是链表中的元素个数。如果某个桶中的元素较多（例如 8 个或更多），查找效率将显著降低。
    	•	红黑树：红黑树是一种自平衡二叉搜索树，其查找、插入和删除操作的时间复杂度是 O(log n)。因此，转换为红黑树后，查找效率大大提高，尤其是在数据量较大的情况下。

    2. HashMap 的设计选择

    在 HashMap 中，桶内存储的是相同哈希值的元素（哈希冲突时）。通常情况下，冲突不会太多，链表的查找性能尚可。但是，当哈希冲突变多时（同一桶内元素数量增加），链表的查找效率会逐渐降低，因此有必要引入更高效的结构来加速查找。

    	•	当桶中的元素较少时（小于等于 8），使用链表，链表结构简单，开销较小，插入和删除操作相对简单。
    	•	当桶中的元素较多时，链表的性能会下降，这时 HashMap 会将链表转换为红黑树，以保证查找、插入和删除操作的效率。

    3. 红黑树相比链表的优点

    	•	更快的查找速度：红黑树的查找、插入、删除的平均时间复杂度为 O(log n)，而链表的查找时间复杂度为 O(n)。当桶内元素较多时，红黑树的查找性能远优于链表。
    	•	平衡结构：红黑树是自平衡的二叉搜索树，任何时候的树高不会太高，能够保证插入、删除、查找操作的性能稳定。而链表则是非平衡的结构，链表越长，性能越差。
    	•	动态调整：HashMap 设计中，只有在元素数量超过一定阈值时才将链表转换为红黑树，这样能够兼顾内存开销和性能。当元素数量较少时，链表更节省内存；而当元素数量较多时，红黑树保证了操作效率。

    4. 为什么不一开始就用红黑树？

    	•	内存开销：红黑树结构比链表复杂，需要维护额外的平衡信息（如节点颜色），这意味着它的内存开销比链表大。当哈希冲突较少时，链表已经能够提供足够的性能，而不需要复杂的红黑树。因此，HashMap 在元素较少时使用链表，这样更加节省空间。
    	•	操作复杂性：红黑树的插入和删除操作比链表要复杂得多，需要维护平衡。对于数量少的元素来说，链表的操作要简单且开销较小。

    总结

    HashMap 在链表转换为红黑树的策略是为了在不同的元素数量下达到更好的性能：

    	•	当元素数量少时，链表的操作更简单、内存开销小；
    	•	当元素数量多时，红黑树的高效查找、插入、删除保证了操作的时间复杂度，避免链表退化成线性查找，提升整体性能。