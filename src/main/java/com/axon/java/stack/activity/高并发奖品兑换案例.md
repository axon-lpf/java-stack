# 兑换码兑换流程

## 代码实现

```java
public JSONResponse redeem(String code, Long userId, String ip) {
    // 1. IP 限制检查
    String ipKey = IP_LIMIT_PREFIX + ip;
    boolean redeem = slidingWindowRateLimiter.isAllowed(ipKey, ipKey, IP_MINUTES * 60, IP_MINUTES_LIMIT);
    if (!redeem) {
        return JSONResponse.newResponse().setError("您的操作过于频繁，稍后再试。");
    }
    return doRedeem(code, userId);
}

private JSONResponse doRedeem(String code, long userId) {
    String lockKey = "redeem:userId:" + userId;
    RLock lock = redissonClient.getLock(lockKey);
    boolean locked = false;
    boolean fail = false;
    try {
        // 2. 分布式锁
        locked = lock.tryLock();
        if (!locked) {
            return JSONResponse.newResponse().setError("您的兑换请求正在处理中，请稍后再试。");
        }

        // 3. 用户锁定检查
        RBucket<Object> bucket = getUserLockBucket(userId);
        if (bucket.isExists()) {
            long ttl = bucket.remainTimeToLive() / 1000;
            String timeUnit = ttl > 60 ? "分钟" : "秒";
            ttl = ttl > 60 ? ttl / 60 : ttl;
            return JSONResponse.newResponse()
                               .setError(String.format("您的兑换功能已锁定。请在%d%s后重试。", ttl, timeUnit));
        }

        // 4. 兑换码验证
        CodeGeneratorUtil codeGenerator = new CodeGeneratorUtil(secretKey);
        if (!codeGenerator.validateCode(code)) {
            return validateRedeemCode(userId, "兑换码格式不正确");
        }

        BenefitActivityRedeemCodeQueryDO codeQueryDO = new BenefitActivityRedeemCodeQueryDO();
        codeQueryDO.setCode(code);
        BenefitActivityRedeemCodeDO redeemCodeDO = benefitActivityRedeemCodeService.selectSingle(codeQueryDO);
        if (redeemCodeDO == null) {
            return validateRedeemCode(userId, "兑换码不存在");
        }

        if (System.currentTimeMillis() > redeemCodeDO.getEndTime()) {
            return validateRedeemCode(userId, "兑换码已过期");
        }

        // 5. 库存管理
        long redeemCount;
        try {
            redeemCount = addAndGetRedeemCount(code, 1);
        } catch (Exception e) {
            log.error("submit addAndGetRedeemCount error", e);
            return JSONResponse.newResponse().setError("活动太火爆了，请稍后重试");
        }

        // 6. 库存验证
        if (redeemCount > redeemCodeDO.getLimitCount()) {
            fail = true;
            return JSONResponse.newResponse().setError("兑换码已被使用");
        }

        // 7. 提交兑换
        JSONResponse response = submit(code, userId, redeemCodeDO);
        if (response.getBusinessCode() != BaseCodeEnum.SC_OK.getCode()) {
            fail = true;
        }
        return response;
    } catch (Exception e) {
        fail = true;
        log.error("兑换失败", e);
        return JSONResponse.newResponse().setError("兑换失败");
    } finally {
        // 8. 错误处理和资源释放
        if (fail) {
            addAndGetRedeemCount(code, -1);
        }
        if (locked) {
            lock.unlock();
        }
    }
}


private JSONResponse submit(String code, Long userId, BenefitActivityRedeemCodeDO redeemCodeDO) {

        //检查用户兑换次数
        BenefitActivityRedeemRecordQueryDO userRedeemRecordQueryDO = new BenefitActivityRedeemRecordQueryDO();
        userRedeemRecordQueryDO.setCode(code);
        userRedeemRecordQueryDO.setUserId(userId);
        Integer userCount = benefitActivityRedeemRecordService.selectCount(userRedeemRecordQueryDO);
        if (userCount >= 1) {
        return JSONResponse.newResponse().setError("兑换码已被使用");
        }
        BenefitActivityRedeemRecordDO redeemRecordDO = new BenefitActivityRedeemRecordDO();
        redeemRecordDO.setActivityCode(redeemCodeDO.getActivityCode());
        redeemRecordDO.setCode(code);
        redeemRecordDO.setProductId(redeemCodeDO.getProductId());
        redeemRecordDO.setSkuId(redeemCodeDO.getSkuId());
        redeemRecordDO.setPrice(redeemCodeDO.getPrice());
        redeemRecordDO.setQuantity(redeemCodeDO.getQuantity());
        redeemRecordDO.setRedemptionTime(System.currentTimeMillis());
        redeemRecordDO.setExpireTime(
        System.currentTimeMillis() + redeemCodeDO.getShippingPeriod() * 24 * 60 * 60 * 1000L);
        redeemRecordDO.setStatus(RedeemPayStatusEnum.PENDING.getValue());
        redeemRecordDO.setIsSelected(1);
        redeemRecordDO.setUserId(userId);
        benefitActivityRedeemRecordService.insert(redeemRecordDO);

        return JSONResponse.newResponse().setMsg("兑换成功");
        }
        
        
```

## 流程说明

1. **IP 限制检查**
    - 使用滑动窗口限流器检查 IP 地址的兑换频率
    - 如果超过限制，返回错误信息

2. **分布式锁**
    - 使用 Redisson 获取分布式锁，防止并发兑换
    - 如果无法获取锁，返回错误信息

3. **用户锁定检查**
    - 检查用户是否因多次错误而被锁定
    - 如果被锁定，返回剩余锁定时间

4. **兑换码验证**
    - 验证兑换码格式和校验和
    - 检查兑换码是否存在
    - 验证兑换码是否过期

5. **库存管理**
    - 增加并获取兑换次数
    - 处理可能出现的异常

6. **库存验证**
    - 检查兑换次数是否超过限制

7. **提交兑换**
    - 执行实际的兑换操作
    - 处理兑换结果

8. **错误处理和资源释放**
    - 捕获所有异常，记录错误日志
    - 如果兑换失败，回滚库存计数
    - 释放分布式锁

## 注意事项

- 使用分布式锁确保并发安全
- 实现了防重复提交机制
- 采用滑动窗口限流控制 IP 访问频率
- 错误次数过多会导致用户兑换功能被临时锁定
- 库存管理采用了乐观锁策略

这个兑换流程设计考虑了并发安全、重复提交、频率限制等多个方面，能够有效地管理兑换码的使用。代码结构清晰，异常处理完善，适合在高并发环境下使用。