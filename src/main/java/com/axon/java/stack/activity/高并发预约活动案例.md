
```markdown
## BenefitUserAppointmentFacade 类

这个类实现了用户预约系统的主要功能，包括提交预约、取消预约和管理预约计数。

### 主要方法

1. `submit` 方法
   - 功能：处理用户提交预约请求
   - 主要步骤：
     1. 使用分布式锁防止重复提交
     2. 增加并获取预约计数
     3. 检查预约限制
     4. 调用 `doSubmit` 方法处理具体预约逻辑

2. `doSubmit` 方法
   - 功能：执行具体的预约提交逻辑
   - 主要步骤：
     1. 验证预约时间段、日程和活动的有效性
     2. 检查用户是否已经预约过（根据预约规则）
     3. 创建并保存预约记录
     4. 更新相关计数

3. `cancel` 方法
   - 功能：处理用户取消预约请求
   - 主要步骤：
     1. 使用分布式锁防止并发操作
     2. 验证预约记录的存在性和状态
     3. 更新预约状态为已取消
     4. 减少相关计数

4. `addAndGetReservedCount` 方法
   - 功能：管理预约计数
   - 使用 Redis 的原子操作来增加或减少预约计数

5. `cancelReservedCount` 方法
   - 功能：取消预约时减少计数

### 关键特性

1. 使用分布式锁（Redisson）来处理并发请求
2. 使用 Redis 的原子操作来管理预约计数
3. 实现了预约规则的检查（如每日一次预约）
4. 处理了各种边界情况（如活动已结束、时间段已满等）

### 注意事项

- 代码中使用了事务操作来确保数据一致性
- 实现了防重复提交和并发控制
- 使用了缓存（Redis）来提高性能和可扩展性

这个类展示了一个相对复杂的预约系统的实现，包含了并发控制、缓存使用、事务处理等多个方面的考虑。

### 源代码

```java
public class BenefitUserAppointmentFacade {

    public  JSONResponse submit(UserAppointmentSubmitVO vo, Long userId, boolean isBetaUser) {
        String lockKey = keyBuilder.build("userAppointment", userId);
        RLock lock = redissonClient.getLock(lockKey);
        boolean locked = false;
        boolean fail = false;
        try {
            locked = lock.tryLock(3, TimeUnit.SECONDS);
            if (!locked) {
                return JSONResponse.newResponse().setError("请勿重复提交");
            }
            long reservedCount;

            try {
                reservedCount = addAndGetReservedCount(vo.getTimeId(), 1);
            } catch (Exception e) {
                log.error("submit addAndGetReservedCount error", e);
                return JSONResponse.newResponse().setError("活动太火爆了，请稍后重试");
            }

            if (reservedCount > benefitActivityScheduleTimeSlotService.selectLimitCount(vo.getTimeId())) {
                fail = true;
                return JSONResponse.newResponse().setError("活动库存不足，请稍后重试");
            }
            JSONResponse response = doSubmit(vo, userId, isBetaUser);
            if (response.getBusinessCode() != BaseCodeEnum.SC_OK.getCode()) {
                fail = true;
            }
            return response;
        } catch (Exception exception) {
            fail = true;
            log.error("doSubmit error", exception);
            return JSONResponse.newResponse().setError("活动太火爆了，请稍后重试");
        } finally {
            if (fail) {
                addAndGetReservedCount(vo.getTimeId(), -1);
            }
            if (locked) {
                lock.unlock();
            }
        }
    }

    private JSONResponse doSubmit(UserAppointmentSubmitVO vo, Long userId, boolean isBetaUser) {

        BenefitActivityScheduleTimeSlotQueryDO timeSlotQueryDO = new BenefitActivityScheduleTimeSlotQueryDO();
        timeSlotQueryDO.setId(vo.getTimeId());
        BenefitActivityScheduleTimeSlotDO timeSlotDO = benefitActivityScheduleTimeSlotService.selectSingle(
                timeSlotQueryDO);
        if (timeSlotDO == null) {
            return JSONResponse.newResponse().setError("预约时间不存在");
        }
        if (timeSlotDO.getReservedCount() >= timeSlotDO.getLimitCount()) {
            return JSONResponse.newResponse().setError("预约时间段人数已约满");
        }
        if (timeSlotDO.getEndTime() < System.currentTimeMillis()) {
            return JSONResponse.newResponse().setError("预约时间已过期");
        }
        BenefitActivityScheduleConfigQueryDO configQueryDO = new BenefitActivityScheduleConfigQueryDO();
        configQueryDO.setId(timeSlotDO.getScheduleId());
        BenefitActivityScheduleConfigDO scheduleConfigDO = benefitActivityScheduleConfigService.selectSingle(
                configQueryDO);
        if (scheduleConfigDO == null) {
            return JSONResponse.newResponse().setError("预约日程不存在");
        }
        BenefitAppointmentActivityQueryDO activityQueryDO = new BenefitAppointmentActivityQueryDO();
        activityQueryDO.setId(scheduleConfigDO.getActivityId());
        BenefitAppointmentActivityDO appointmentActivityDO = appointmentActivityService.selectSingle(activityQueryDO);
        if (appointmentActivityDO == null) {
            return  JSONResponse.newResponse().setError("预约活动不存在");
        }
        if (appointmentActivityDO.getActivityEndTime() < System.currentTimeMillis()) {
            return JSONResponse.newResponse().setError("预约活动已结束");
        }
        if (appointmentActivityDO.getReservationStartTime() > System.currentTimeMillis()) {
            return JSONResponse.newResponse().setError("预约活动未开始");
        }
        //每日一次
        if (ReservationRuleEnum.ONCE.getValue().equals(scheduleConfigDO.getReservationRule())) {
            BenefitUserAppointmentQueryDO queryDO = new BenefitUserAppointmentQueryDO();
            queryDO.setUserId(userId);
            queryDO.setStoreId(appointmentActivityDO.getStoreId());
            queryDO.setActivityId(scheduleConfigDO.getActivityId());
            queryDO.setScheduleId(scheduleConfigDO.getId());
            queryDO.setAppointmentStatusList(
                    Arrays.asList(AppointmentStatusEnum.PENDING.getValue(), AppointmentStatusEnum.REDEEMED.getValue()));
            Integer count = benefitUserAppointmentService.selectCount(queryDO);
            if (count != null && count > 0 && !isBetaUser) {
                return JSONResponse.newResponse().setError("您已预约过该日程");
            }
        } else {
            //即使无上限，一段时间内只能预约一次
            BenefitUserAppointmentQueryDO queryDO = new BenefitUserAppointmentQueryDO();
            queryDO.setUserId(userId);
            queryDO.setStoreId(appointmentActivityDO.getStoreId());
            queryDO.setActivityId(scheduleConfigDO.getActivityId());
            queryDO.setAppointmentStartTime(timeSlotDO.getStartTime());
            queryDO.setAppointmentEndTime(timeSlotDO.getEndTime());
            queryDO.setAppointmentStatusList(
                    Arrays.asList(AppointmentStatusEnum.PENDING.getValue(), AppointmentStatusEnum.REDEEMED.getValue()));
            Integer count = benefitUserAppointmentService.selectCount(queryDO);
            if (count != null && count > 0 && !isBetaUser) {
                return JSONResponse.newResponse().setError("您已预约过该时间段");
            }
        }
        BenefitUserAppointmentDO appointmentDO = new BenefitUserAppointmentDO();
        appointmentDO.setAppointmentDate(Integer.valueOf(com.netease.loft.util.common.TimeUtils.formatTimeDayNoSpace(new Date(scheduleConfigDO.getScheduleDate()))));
        appointmentDO.setUserId(userId);
        appointmentDO.setStoreId(appointmentActivityDO.getStoreId());
        appointmentDO.setActivityId(scheduleConfigDO.getActivityId());
        appointmentDO.setAppointmentStartTime(timeSlotDO.getStartTime());
        appointmentDO.setAppointmentEndTime(timeSlotDO.getEndTime());
        appointmentDO.setAppointmentStatus(AppointmentStatusEnum.PENDING.getValue());
        appointmentDO.setScheduleId(scheduleConfigDO.getId());
        appointmentDO.setTimeSlotId(timeSlotDO.getId());
        benefitUserAppointmentService.insert(appointmentDO, id -> {
            //处理预日程表增加约人数
            benefitActivityScheduleConfigService.increaseReservedCount(scheduleConfigDO.getId());
            //处理预约时间范围的增加预约人数
            benefitActivityScheduleTimeSlotService.increaseReservedCount(timeSlotDO.getId());
        });
        return JSONResponse.newResponse().addDataItem("id", appointmentDO.getId());
    }

    public JSONResponse cancel(UserAppointmentCancelVO vo, Long userId) {
        String lockKey = keyBuilder.build("userAppointmentCancel", userId);
        RLock lock = redissonClient.getLock(lockKey);
        boolean locked = false;
        try {
            locked = lock.tryLock(3, TimeUnit.SECONDS);
            if (!locked) {
                return JSONResponse.newResponse().setError("请勿重复提交");
            }
            BenefitUserAppointmentDO appointmentDO = benefitUserAppointmentService.selectSingleById(vo.getId(), userId);
            if (appointmentDO == null) {
                return JSONResponse.newResponse().setError("预约记录不存在");
            }
            if (!Objects.equals(appointmentDO.getAppointmentStatus(), AppointmentStatusEnum.PENDING.getValue())) {
                return JSONResponse.newResponse().setError("预约记录已取消或已核销");
            }
            if (appointmentDO.getAppointmentEndTime() < System.currentTimeMillis()) {
                return JSONResponse.newResponse().setError("预约记录已过期,不能取消");
            }
            BenefitUserAppointmentDO updateAppointment = new BenefitUserAppointmentDO();
            updateAppointment.setId(appointmentDO.getId());
            updateAppointment.setAppointmentStatus(AppointmentStatusEnum.CANCELED.getValue());
            benefitUserAppointmentService.updateById(updateAppointment, id -> {
                //处理预日程表减少约人数
                benefitActivityScheduleConfigService.decreaseReservedCount(appointmentDO.getScheduleId());
                //处理预约时间范围的减少预约人数
                benefitActivityScheduleTimeSlotService.decreaseReservedCount(appointmentDO.getTimeSlotId());
            });
            //减少缓存中已预约的数量
            cancelReservedCount(appointmentDO.getTimeSlotId());
            return JSONResponse.newResponse();
        } catch (Exception exception) {
            log.error("doCancel error", exception);
            return JSONResponse.newResponse().setError("取消失败,请稍后重试");
        } finally {

            if (locked) {
                lock.unlock();
            }
        }
    }

    /**
     *  已预约人数
     * @param timeSlotId 预约时间段id
     * @param delta 预约数量
     * @return 预约数量
     */
    private long addAndGetReservedCount(Long timeSlotId, int delta) {
        String lockKey = keyBuilder.build("reservedCount", timeSlotId);
        RAtomicLong stock = redissonClient.getAtomicLong(lockKey);
        if (!stock.isExists()) {
            BenefitActivityScheduleTimeSlotQueryDO timeSlotQueryDO = new BenefitActivityScheduleTimeSlotQueryDO();
            timeSlotQueryDO.setId(timeSlotId);
            BenefitActivityScheduleTimeSlotDO timeSlotDO = benefitActivityScheduleTimeSlotService.selectSingle(
                    timeSlotQueryDO);
            if (timeSlotDO == null) {
                throw new MiniBusinessException("预约时间段不存在");
            }
            boolean b = stock.compareAndSet(0, timeSlotDO.getReservedCount());
            if (!b) {
                throw new MiniBusinessException("活动太火爆了，请稍后再试");
            }
            stock.expire(2, TimeUnit.DAYS);
        }
        return stock.addAndGet(delta);
    }
```

