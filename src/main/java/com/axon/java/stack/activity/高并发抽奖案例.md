# JusticeOnlineService 类

这个类实现了一个在线抽奖系统的核心功能，包括库存管理和抽奖逻辑。

## 主要方法

### addAndGetStock

```java
private long addAndGetStock(int delta) {
    String lockKey = keyBuilder.build("collectLock", justiceOnlinePartnerActivityId);
    RAtomicLong stock = redissonClient.getAtomicLong(lockKey);
    if (!stock.isExists()) {
        int collectCount = userActivityRecordRepository.getCountByType(justiceOnlinePartnerActivityId, LOTTERY);
        long remainCount = bigGiftPackageCount - collectCount;
        stock.compareAndSet(0, remainCount);
        stock.expire(Duration.ofDays(60));
    }
    return stock.addAndGet(delta);
}
```

这个方法用于管理和更新库存。它使用Redis的原子操作来确保并发安全。

- 如果库存计数不存在，它会初始化库存
- 使用`addAndGet`方法来更新库存
- 设置60天的过期时间

### slot

```java
public Result<LuckBingoVO> slot(long userId, String ip) {
    String lockKey = keyBuilder.build("slotLock", userId, justiceOnlineActivityId);
    RLock lock = redissonClient.getLock(lockKey);
    if (!lock.tryLock()) {
        return new Result<LuckBingoVO>().setCode(BaseBusinessCode.SC_BAD_REQUEST)
                                        .setErrorMsg("操作太快了，请稍后再试");
    }
    List<PartnerLuckPrizeVO> unCollectList = getUnCollectPartner(userId);
    boolean excludeControl = unCollectList.size() == 1;
    try {
        Set<Long> excludePrizeIds = null;
        if (excludeControl) {
            // 预减库存
            if (addAndGetStock(-1) < 0) {
                excludePrizeIds = unCollectList.stream().map(PartnerLuckPrizeVO::getId).collect(Collectors.toSet());
            }
        }
        return doSlot(userId, ip, excludePrizeIds);
    }  finally {
        if (excludeControl && !ObjectUtils.isEmpty(getUnCollectPartner(userId))) {
            // 归还库存
            addAndGetStock(1);
        }
        lock.unlock();
    }
}
```

这个方法处理用户的抽奖请求。

- 使用分布式锁防止并发操作
- 检查未收集的奖品
- 预减库存并处理边界情况
- 调用`doSlot`方法执行实际的抽奖逻辑
- 在finally块中处理库存归还和解锁

### doSlot

```java
private Result<LuckBingoVO> doSlot(long userId, String ip, Set<Long> excludePrizeIds) {
    long userScore = getUserScore(userId, true);
    if (userScore < point) {
        return new Result<LuckBingoVO>().setCode(BaseBusinessCode.SC_BAD_REQUEST).setErrorMsg("当前剩余次数不足");
    }

    String reqId = UUID.randomUUID().toString();
    //扣除积分
    userScoreDao.addScore(userId, justiceOnlineActivityId, "slot", -point, reqId, "");

    // 抽奖
    ActivitySlotParam param = ActivitySlotParam.builder().appKey(JUSTICE_ONLINE_ACTIVITY_APP_KEY)
                                               .activityId(justiceOnlineActivityId)
                                               .userId(String.valueOf(userId)).slotNum(1).checkSlotChance(false)
                                               .reqId(reqId).build();

    //抽搭子
    ActivitySlotParam.ActivitySlotParamBuilder<?, ?> builder = ActivitySlotParam.builder();
    builder.appKey(JUSTICE_ONLINE_PARTNER_ACTIVITY_APP_KEY).activityId(justiceOnlinePartnerActivityId)
           .userId(String.valueOf(userId)).slotNum(1).checkSlotChance(false).reqId(reqId);
    if (!ObjectUtils.isEmpty(excludePrizeIds)) {
        builder.excludePrizeIds(excludePrizeIds);
    }
    ActivitySlotParam partnerParam = builder.build();

    List<LuckBingoVO> bingoList = luckActivityService.multiActivityBatchSlot(
            Arrays.asList(param, partnerParam));
    if (ObjectUtils.isEmpty(bingoList)) {
        return new Result<LuckBingoVO>().setCode(BaseBusinessCode.SC_INTERNAL_SERVER_ERROR)
                                        .setErrorMsg("抽奖出错");
    }

    //异步插入记录
    CompletableFuture.runAsync(() -> insertActivityRecord(userId,ip),
                               ioIntensiveExecutor);
    //异步发放奖品通知
    CompletableFuture.runAsync(() -> grantBingo(bingoList, justiceOnlineActivityId, userId),
                               ioIntensiveExecutor);
    return new Result<LuckBingoVO>().setDataList(bingoList);
}
```

这个方法执行实际的抽奖逻辑。

- 检查用户积分
- 扣除积分
- 执行抽奖操作
- 异步插入活动记录和发放奖品通知

## 关键特性

1. 使用Redis进行并发控制和库存管理
2. 实现了预减库存和库存归还机制
3. 使用异步操作处理非关键路径任务
4. 处理了各种边界情况（如积分不足、抽奖错误等）

## 注意事项

- 代码中使用了分布式锁来确保并发安全
- 实现了防重复提交机制
- 使用了异步处理来提高性能
- 需要注意异常处理和事务管理（代码中未完全展示）

这个类展示了一个相对复杂的在线抽奖系统的实现，包含了并发控制、库存管理、异步处理等多个方面的考虑。