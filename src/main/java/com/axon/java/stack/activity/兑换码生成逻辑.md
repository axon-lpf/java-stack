

```java

package com.netease.lofter.benefit.mini.util;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.time.LocalDateTime;
import java.util.concurrent.atomic.AtomicLong;

/**
* 安全兑换码生成器
* 用于生成和验证安全的兑换码
  */
  public class CodeGeneratorUtil {
  // 定义字符集，包含数字和大小写字母
  private static final String CHARS = "fNQRvSqEp9UaXkVWmYZbcdeghjnFHMtuwxyzA2B3C4D5G6J7K8LTPrs";

  // 定义兑换码长度为8
  private static final int CODE_LENGTH = 8;

  // 定义随机部分长度为5
  private static final int RANDOM_LENGTH = 5;

  private static final int TIME_CODE_LENGTH = 2;


    private static final AtomicLong counter = new AtomicLong(System.currentTimeMillis());


    // 用于生成校验和的密钥
    private final String secretKey;

    /**
     * 构造函数
     *
     * @param secretKey 用于生成校验和的密钥
     */
    public CodeGeneratorUtil(String secretKey) {
        this.secretKey = secretKey;
    }

    /**
     * 生成兑换码
     *
     * @return 生成的兑换码
     */
    public String generateCode() {
        StringBuilder code = new StringBuilder(CODE_LENGTH);

        // 1. 生成5位随机字符
        SecureRandom random = new SecureRandom();
        for (int i = 0; i < RANDOM_LENGTH; i++) {
            code.append(CHARS.charAt(random.nextInt(CHARS.length())));
        }

        // 2. 添加2位时间编码
        String timeCode = encodeTime();
        code.append(timeCode);

        // 3. 计算并添加1位校验码
        char checksum = calculateChecksum(code.toString());
        code.append(checksum);

        return code.toString();
    }

    /**
     *
     * long count = counter.getAndIncrement() & 0xFFFFFF;
     *
     * counter.getAndIncrement(): 这里的 counter 很可能是一个 AtomicLong 类型的原子计数器。getAndIncrement() 方法会原子地获取当前值并将其加1。这保证了在多线程环境下的线程安全。
     *
     * & 0xFFFFFF: 这是一个位与操作。0xFFFFFF 是一个十六进制数，对应的二进制是 24 个 1。这个操作会保留 counter 值的低 24 位，相当于对 2^24 (16,777,216) 取模。
     *
     * 结果：count 变量将包含一个 0 到 16,777,215 之间的值。
     *
     * timeCode = (timeCode << 24) | count;
     *
     * timeCode << 24: 将 timeCode 左移 24 位。这会在 timeCode 的低 24 位创造出空间。
     *
     * |: 这是位或操作。它将左移后的 timeCode 和 count 合并。
     *
     * 结果：新的 timeCode 的高位保持原样，而低 24 位被 count 的值替换。
     *
     * 这两行代码的目的是：
     *
     * 引入一个快速变化的计数器，范围是 0 到 16,777,215。
     * 将这个计数器的值合并到时间编码中，占用低 24 位。
     * 这样做有几个好处：
     *
     * 增加了生成码的唯一性。即使在同一秒内生成多个码，由于计数器的存在，它们也会是不同的。
     * 提高了生成速度。在短时间内可以生成大量不重复的码。
     * 保持了时间信息的完整性。原始的时间信息被保留在高位，而计数器信息被添加到低位。
     * 这种方法巧妙地结合了时间戳和计数器，既保证了唯一性，又包含了时间信息，同时还能支持高并发的码生成需求。
     *
     * @return 编码后的时间字符串
     */
    private String encodeTime() {
        LocalDateTime now = LocalDateTime.now();

        // 使用年份的后两位
        int year = now.getYear() % 100;
        int month = now.getMonthValue();
        int day = now.getDayOfMonth();
        int hour = now.getHour();
        int minute = now.getMinute();
        int second = now.getSecond();

        // 将日期时间压缩成一个长整数
        long timeCode = (year * 12L + month) * 31 + day; // 日期部分
        timeCode = (timeCode * 24 + hour) * 60 + minute; // 加上小时和分钟
        timeCode = timeCode * 60 + second; // 加上秒

        //加入一个快速变化的计数器，范围 0-16777215
        long count = counter.getAndIncrement() & 0xFFFFFF;
        timeCode = (timeCode << 24) | count;

        // 使用自定义的62进制编码
        return encodeBase62(timeCode);
    }

    /**
     * 这个方法将长整数编码为 62 进制的 2 字符字符串。它通过不断取余和除法来转换进制，最后反转字符串得到正确的顺序。
     */
    private String encodeBase62(long value) {
        StringBuilder sb = new StringBuilder(TIME_CODE_LENGTH);
        for (int i = 0; i < TIME_CODE_LENGTH; i++) {
            sb.append(CHARS.charAt((int)(value % CHARS.length())));
            value /= CHARS.length();
        }
        return sb.reverse().toString();
    }



    /**
     * 计算输入字符串的校验和
     *
     * @param input 输入字符串
     * @return 校验和字符
     */
    private char calculateChecksum(String input) {
        try {
            // 使用HmacSHA256算法计算HMAC
            Mac hmac = Mac.getInstance("HmacSHA256");
            // 创建一个SecretKeySpec对象，用于初始化HMAC
            SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey.getBytes(), "HmacSHA256");
            // 初始化HMAC
            hmac.init(secretKeySpec);
            // 计算输入字符串的HMAC值
            byte[] hash = hmac.doFinal(input.getBytes(StandardCharsets.UTF_8));
            // 计算hash的字节和
            int sum = 0;
            for (byte b : hash) {
                sum += b;
            }
            // 将和映射到CHARS中的一个字符，作为校验和
            return CHARS.charAt(Math.abs(sum) % CHARS.length());
        } catch (NoSuchAlgorithmException | InvalidKeyException e) {
            // 如果发生异常，抛出运行时异常
            throw new RuntimeException("Failed to calculate checksum", e);
        }
    }


    /**
     * 验证兑换码是否有效
     *
     * @param code 待验证的兑换码
     * @return 如果兑换码有效返回true，否则返回false
     */
    /**
     * 验证兑换码是否有效
     *
     * @param code 待验证的兑换码
     * @return 如果兑换码有效返回true，否则返回false
     */
    public boolean validateCode(String code) {
        // 检查输入的兑换码是否为null或长度不符合要求
        if (code == null || code.length() != CODE_LENGTH) {
            return false;
        }

        // 分离兑换码和校验和
        // 提取除最后一位之外的所有字符作为兑换码主体
        String codeWithoutChecksum = code.substring(0, CODE_LENGTH - 1);
        // 获取最后一位字符作为提供的校验和
        char providedChecksum = code.charAt(CODE_LENGTH - 1);

        // 重新计算校验和
        char calculatedChecksum = calculateChecksum(codeWithoutChecksum);

        // 比较计算得到的校验和与提供的校验和是否相同
        return calculatedChecksum == providedChecksum;
    }

    public static void main(String[] args) {

        CodeGeneratorUtil codeGenerator = new CodeGeneratorUtil("your_secret_key");
        for (int i = 0; i < 10; i++) {
            String s = codeGenerator.generateCode();
            System.out.println(codeGenerator.validateCode(s));
        }
    }
}

```