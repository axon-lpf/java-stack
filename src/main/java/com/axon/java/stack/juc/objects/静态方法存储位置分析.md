# 🧠 **静态方法存储位置分析**

## 📍 **答案：方法区/元空间**

```java
private static void method(){} // 字节码存储在：方法区(JDK7-) / 元空间(JDK8+)
```

## 🔍 **详细分析**

### **JDK 8+ 内存布局**
```java
┌─────────────────────────────────────┐
│            元空间 (Metaspace)        │
├─────────────────────────────────────┤
│ ObjectTest.class 元数据 {           │
│   ✅ method()字节码                  │
│   ✅ 方法签名信息                    │
│   ✅ 访问修饰符                      │
│   ✅ 异常表                         │
│ }                                   │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│              堆内存 (Heap)            │
├─────────────────────────────────────┤
│ Class对象区域 {                      │
│   ❌ 不包含方法字节码                 │
│   ✅ 静态字段引用                     │
│   ✅ 类的运行时信息                   │
│ }                                   │
└─────────────────────────────────────┘
```

### **JDK 7及之前**
```java
┌─────────────────────────────────────┐
│          永久代 (PermGen)            │
├─────────────────────────────────────┤
│ ✅ 静态方法字节码                    │
│ ✅ 静态字段引用                      │
│ ✅ 类元数据                         │
│ ✅ 常量池                           │
└─────────────────────────────────────┘
```

## 🧪 **验证代码**

```java
import java.lang.reflect.Method;

public class StaticMethodLocationTest {
    
    private static void testMethod() {
        System.out.println("这是一个静态方法");
    }
    
    private void instanceMethod() {
        System.out.println("这是一个实例方法");
    }
    
    public static void main(String[] args) throws Exception {
        // 1. 获取类的元数据信息
        Class<?> clazz = StaticMethodLocationTest.class;
        System.out.println("Class对象: " + clazz);
        System.out.println("Class对象地址: " + System.identityHashCode(clazz));
        
        // 2. 获取静态方法
        Method staticMethod = clazz.getDeclaredMethod("testMethod");
        System.out.println("\n=== 静态方法信息 ===");
        System.out.println("方法名: " + staticMethod.getName());
        System.out.println("是否静态: " + java.lang.reflect.Modifier.isStatic(staticMethod.getModifiers()));
        System.out.println("方法对象: " + staticMethod);
        
        // 3. 获取实例方法
        Method instanceMethod = clazz.getDeclaredMethod("instanceMethod");
        System.out.println("\n=== 实例方法信息 ===");
        System.out.println("方法名: " + instanceMethod.getName());
        System.out.println("是否静态: " + java.lang.reflect.Modifier.isStatic(instanceMethod.getModifiers()));
        System.out.println("方法对象: " + instanceMethod);
        
        // 4. 查看JVM内存信息
        printJVMInfo();
        
        // 5. 执行方法
        System.out.println("\n=== 方法执行 ===");
        staticMethod.invoke(null); // 静态方法不需要实例
        
        StaticMethodLocationTest instance = new StaticMethodLocationTest();
        instanceMethod.invoke(instance); // 实例方法需要对象实例
    }
    
    public static void printJVMInfo() {
        System.out.println("\n=== JVM内存信息 ===");
        Runtime runtime = Runtime.getRuntime();
        System.out.println("Java版本: " + System.getProperty("java.version"));
        System.out.println("JVM版本: " + System.getProperty("java.vm.version"));
        System.out.println("堆内存使用: " + (runtime.totalMemory() - runtime.freeMemory()) / 1024 / 1024 + "MB");
        
        // 查看类加载器信息
        ClassLoader classLoader = StaticMethodLocationTest.class.getClassLoader();
        System.out.println("类加载器: " + classLoader);
    }
}
```

## 📊 **方法存储对比表**

| 方法类型 | JDK 7及之前 | JDK 8+ | 执行时 |
|---------|------------|--------|--------|
| **静态方法** | 方法区(PermGen) | 元空间(Metaspace) | 直接从元空间加载执行 |
| **实例方法** | 方法区(PermGen) | 元空间(Metaspace) | 通过对象引用执行 |
| **方法字节码** | PermGen | Metaspace | 所有方法字节码都在这里 |

## 🔧 **内存区域详解**

### **1️⃣ 元空间 (Metaspace) - JDK 8+**
```java
元空间内容 {
    ✅ 类的字节码 (包括静态方法)
    ✅ 方法元数据
    ✅ 常量池信息
    ✅ 类结构信息
    ❌ 不包含静态变量的值
}

特点:
- 使用本地内存，不占用堆空间
- 自动扩展，减少OOM风险
- 更高效的垃圾回收
```

### **2️⃣ 堆内存中的Class对象**
```java
Class对象内容 {
    ✅ 静态字段的引用
    ✅ 类的运行时信息
    ✅ 反射相关数据
    ❌ 不包含方法字节码
}
```

## ⚡ **字节码查看工具**

### **查看方法字节码**
```bash
# 编译Java文件
javac StaticMethodLocationTest.java

# 查看字节码
javap -c StaticMethodLocationTest

# 详细信息
javap -v StaticMethodLocationTest
```

### **输出示例**
```java
private static void testMethod();
  descriptor: ()V
  flags: ACC_PRIVATE, ACC_STATIC
  Code:
    stack=2, locals=0, args_size=0
       0: getstatic     #2    // Field java/lang/System.out:Ljava/io/PrintStream;
       3: ldc           #3    // String 这是一个静态方法
       5: invokevirtual #4    // Method java/io/PrintStream.println:(Ljava/lang/String;)V
       8: return
```

## 🎯 **关键区别总结**

### **静态方法 vs 静态字段**
```java
class Example {
    private static String field = "value";    // 引用在堆中Class对象
    private static void method() {}           // 字节码在元空间
}

内存分布:
┌─── 元空间 ───┐    ┌─── 堆内存 ───┐
│ method()字节码 │    │ Class对象    │
│             │    │ ├─ field引用  │
│             │    │ └─ "value"对象│
└─────────────┘    └─────────────┘
```

## 🚀 **性能影响**

### **1️⃣ 方法调用开销**
```java
// 静态方法调用 - 直接从元空间加载
StaticMethodLocationTest.testMethod();  // 低开销

// 实例方法调用 - 需要对象引用
instance.instanceMethod();              // 稍高开销
```

### **2️⃣ 内存占用**
```java
- 方法字节码: 加载一次，所有实例共享
- 执行栈帧: 每次调用创建，调用结束销毁
- 局部变量: 存储在栈帧中
```

## 💡 **最佳实践**

1. **静态方法字节码在元空间，所有实例共享**
2. **避免过度使用反射调用静态方法**
3. **合理设置元空间大小** (`-XX:MetaspaceSize`)
4. **监控元空间使用情况**

总结：**静态方法的字节码存储在元空间(JDK8+)或方法区(JDK7-)中**！🎯