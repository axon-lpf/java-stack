针对 老年代内存占用 70% 时立即进行 Full GC 的优化，实际上是通过调整 JVM 的垃圾回收参数 来实现的。具体而言，您可以通过调整 -XX:InitiatingHeapOccupancyPercent 参数来控制何时触发 Full GC。

相关参数：
	1.	-XX:InitiatingHeapOccupancyPercent：
	•	作用：此参数控制 老年代（即 Tenured Generation）占用堆内存的百分比，决定了 G1 GC（Garbage-First GC）开始执行 混合垃圾回收（Mixed GC） 的阈值。默认情况下，G1 垃圾收集器会在老年代占用堆内存达到 45% 时触发 Full GC。
	•	优化方法：为了减少 Full GC 停顿时间，可以将此参数设置为 70%，这样当老年代的堆内存占用达到 70% 时，JVM 会开始进行 Full GC，从而避免长时间等待的停顿。
示例配置：
    -XX:InitiatingHeapOccupancyPercent=70


 2.	-XX:MaxGCPauseMillis：
 	•	作用：指定垃圾收集的最大停顿时间，JVM 会尝试尽可能在这个时间限制内完成垃圾收集。
 	•	优化方法：与 -XX:InitiatingHeapOccupancyPercent 配合使用，进一步调整停顿时间的限制，帮助在达到一定内存占用时减少 GC 停顿对响应时间的影响。
 示例配置：
    -XX:MaxGCPauseMillis=200  # 限制 GC 停顿最大时间为 200ms


 -XX:MaxGCPauseMillis=200 这个参数的作用是 限制 JVM 垃圾回收过程中每次停顿的最大时间。它指定了 垃圾收集 （GC）在每次回收过程中的 最大停顿时间，单位为 毫秒。如果 GC 过程的停顿时间超过了这个限制，JVM 会尽量 调整 回收策略，以控制停顿时间，不让它超过指定的时间。
 具体效果：
 	1.	目标停顿时间的设置：
 设置 -XX:MaxGCPauseMillis=200 意味着 JVM 将尽量保证垃圾回收的每次停顿不超过 200ms。这个时间限制适用于 G1 GC、CMS GC 和其他垃圾回收器。
 	2.	JVM 调整回收行为：
 JVM 会根据这个限制来 调整垃圾回收策略。如果回收器认为某一轮 GC 无法在 200ms 内完成，它可能会：
 	•	缩短回收工作量：通过减少每次 GC 过程中回收的对象数量，来降低停顿时间。
 	•	牺牲吞吐量：可能会导致 JVM 更频繁地进行垃圾回收，减少每次回收的工作量，从而降低每次 GC 的时间，但这也可能会影响系统的吞吐量（即单位时间内处理的请求数）。
 	•	改变回收策略：回收器可能会选择更“温和”的回收方式，比如 增量式回收，以保证不会超过最大停顿时间。
 	3.	停顿时间不能保证完全精确：
 这个设置是一个 目标值，并不是一个绝对的强制限制。虽然 JVM 会尽量在 200ms 内完成垃圾回收，但如果垃圾回收的工作量非常大，JVM 可能会 无法在这个时间限制内完成。这种情况下，JVM 可能会 调整策略，或者 增加停顿时间，但它会尽量避免长时间的停顿。
 	4.	中断和 GC 影响：
 	•	如果您的应用程序的 GC 停顿时间 原本是 500ms，设置了 -XX:MaxGCPauseMillis=200 后，JVM 会尽量在 200ms 内完成 GC。并不会直接“中断” GC，但 JVM 会试图调整回收策略，例如减少每次 GC 的工作量或增加 GC 的频率，从而导致 GC 时间被压缩。
 	•	这种设置可能会导致 GC 更频繁，但每次的停顿时间较短。理论上，它会减少每次 GC 造成的影响，但会增加系统的 GC 总体频率，这可能影响系统的吞吐量和性能。

 总结：

 -XX:MaxGCPauseMillis=200 设定后，JVM 将尽力保证垃圾回收停顿时间不超过 200ms。这个设置并不会“中断” GC，而是让 JVM 尝试 调整 GC 的策略，以确保每次回收停顿的时间限制。如果回收过程本身需要更长的时间，JVM 会调整回收方式，可能通过 增加 GC 频率 或 减少回收工作量 来确保停顿时间符合目标值。但这种做法可能会影响吞吐量和性能，因此需要根据具体场景进行测试和调整。