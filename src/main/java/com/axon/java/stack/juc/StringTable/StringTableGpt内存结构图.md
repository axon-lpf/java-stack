```java
public class StringTest01 {

    public static void demo01(){
        // 🎯 关键：通过字符串拼接创建，不会自动进入常量池
        String s1 = new String("a") + new String("b");  // 在堆中创建"ab"对象，s1指向堆地址

        // 🔑 JDK1.7+: 常量池中没有"ab"，将s1指向的堆对象引用存入常量池
        String intern = s1.intern();  // 返回s1的引用（指向同一个堆对象）

        // 📋 常量池中已有"ab"引用，直接返回（指向s1的堆对象）
        String s2 = "ab";  

        System.out.println(s1 == s2);     // true - 都指向同一个堆对象
        System.out.println(s2 == intern); // true - 都指向同一个堆对象
    }

    public static void demo02(){
        // ⚠️ 重要：new String("ab") 会同时创建两个对象！
        // 1. 字面量"ab"进入常量池  2. new String()在堆中创建对象
        String s1 = new String("ab"); // s1指向堆中的String对象

        // 🔑 常量池中已经有"ab"（字面量创建的），直接返回常量池引用
        String intern = s1.intern(); // 返回常量池中的"ab"引用

        // 📋 返回常量池中已有的"ab"引用
        String s2 = "ab";  

        System.out.println(s1 == s2);     // false - s1指向堆，s2指向常量池
        System.out.println(s2 == intern); // true - 都指向常量池
    }

    public static void demo03(){
        // 📋 在常量池中创建"ab"
        String x = "ab";  

        // 🎯 在堆中创建"ab"对象（拼接方式不会自动进入常量池）
        String s1 = new String("a") + new String("b"); 

        // 🔑 常量池中已有"ab"，返回常量池引用
        String intern = s1.intern(); 

        // 📋 返回常量池中的"ab"引用
        String s2 = "ab"; 

        System.out.println(s1 == s2);     // false - s1指向堆，s2指向常量池
        System.out.println(s2 == intern); // true - 都指向常量池
    }
}
```

## 🤔 **为什么会有这样的区别？**

### **1. 字符串创建方式的区别**

| 创建方式 | 是否自动进常量池 | 示例 |
|----------|------------------|------|
| `"abc"` | ✅ 是 | `String s = "abc";` |
| `new String("abc")` | ❌ 否，但字面量会进常量池 | `String s = new String("abc");` |
| `"a" + "b"` | ✅ 是（编译期优化） | `String s = "a" + "b";` |
| `new String("a") + new String("b")` | ❌ 否 | 如demo01 |

### **2. intern() 在JDK 1.7+的行为变化**

```java
// JDK 1.6 及之前的行为
String s1 = new String("a") + new String("b");
String intern = s1.intern(); // 在常量池中创建新的"ab"拷贝
// s1 != intern （不同对象）

// JDK 1.7+ 的行为  
String s1 = new String("a") + new String("b");
String intern = s1.intern(); // 在常量池中存储s1的引用
// s1 == intern （同一对象）
```

## 🗺️ **内存结构图**

### **Demo01 内存结构图**
```
┌─────────────────────────────────────────────────────────────┐
│                        JVM 内存结构                          │
├─────────────────────────────────────────────────────────────┤
│                         堆内存 (Heap)                        │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                   Young Generation                     │ │
│  │  ┌─────────────────────────────────────────────────────┤ │
│  │  │  String对象 "ab"  ←─────┐                          │ │
│  │  │  value: ['a','b']       │                          │ │
│  │  │  地址: @1001            │                          │ │  
│  │  └─────────────────────────│───────────────────────────┤ │
│  └─────────────────────────────│───────────────────────────┘ │
│                                │                             │
│  ┌─────────────────────────────▼───────────────────────────┐ │
│  │              字符串常量池 (StringTable)                  │ │
│  │  ┌─────────────────────────────────────────────────────┤ │
│  │  │ "ab" → @1001  (存储堆中对象的引用)                  │ │
│  │  └─────────────────────────────────────────────────────┤ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘

栈内存 (Stack):
┌─────────────────────────┐
│ s1      → @1001        │  ───┐
│ intern  → @1001        │     │ 都指向同一个堆对象
│ s2      → @1001        │  ───┘
└─────────────────────────┘

执行流程:
1. s1 = new String("a") + new String("b") → 堆中创建"ab"对象
2. s1.intern() → 常量池中存储@1001引用，返回@1001
3. s2 = "ab" → 从常量池获取@1001引用
4. 结果: s1 == s2 == intern (true)
```

### **Demo02 内存结构图**
```
┌─────────────────────────────────────────────────────────────┐
│                        JVM 内存结构                          │
├─────────────────────────────────────────────────────────────┤
│                         堆内存 (Heap)                        │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                   Young Generation                     │ │
│  │  ┌─────────────────────────────────────────────────────┤ │
│  │  │  String对象 "ab"  ←─────┐                          │ │
│  │  │  value: ['a','b']       │                          │ │
│  │  │  地址: @1002            │                          │ │  
│  │  └─────────────────────────│───────────────────────────┤ │
│  └─────────────────────────────│───────────────────────────┘ │
│                                │                             │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │              字符串常量池 (StringTable)                  │ │
│  │  ┌─────────────────────────────────────────────────────┤ │
│  │  │  String对象 "ab"  ←─────┐                          │ │
│  │  │  value: ['a','b']       │                          │ │
│  │  │  地址: @1003            │                          │ │
│  │  └─────────────────────────│───────────────────────────┤ │
│  └─────────────────────────────│───────────────────────────┘ │
└─────────────────────────────────│───────────────────────────┘
                                  │
栈内存 (Stack):                    │
┌─────────────────────────┐        │
│ s1      → @1002        │  ──────┘
│ intern  → @1003        │  ───┐
│ s2      → @1003        │  ───┘ 指向常量池对象
└─────────────────────────┘

执行流程:
1. s1 = new String("ab") → 常量池创建@1003，堆中创建@1002
2. s1.intern() → 常量池中已有"ab"@1003，返回@1003
3. s2 = "ab" → 从常量池获取@1003引用
4. 结果: s1 != s2 (false), s2 == intern (true)
```

### **Demo03 内存结构图**
```
┌─────────────────────────────────────────────────────────────┐
│                        JVM 内存结构                          │
├─────────────────────────────────────────────────────────────┤
│                         堆内存 (Heap)                        │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                   Young Generation                     │ │
│  │  ┌─────────────────────────────────────────────────────┤ │
│  │  │  String对象 "ab"  ←─────┐                          │ │
│  │  │  value: ['a','b']       │                          │ │
│  │  │  地址: @1005            │                          │ │  
│  │  └─────────────────────────│───────────────────────────┤ │
│  └─────────────────────────────│───────────────────────────┘ │
│                                │                             │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │              字符串常量池 (StringTable)                  │ │
│  │  ┌─────────────────────────────────────────────────────┤ │
│  │  │  String对象 "ab"  ←─────┐                          │ │
│  │  │  value: ['a','b']       │                          │ │
│  │  │  地址: @1004            │                          │ │
│  │  └─────────────────────────│───────────────────────────┤ │
│  └─────────────────────────────│───────────────────────────┘ │
└─────────────────────────────────│───────────────────────────┘
                                  │
栈内存 (Stack):                    │
┌─────────────────────────┐        │
│ x       → @1004        │  ───┐   │
│ s1      → @1005        │  ──┘│───┘
│ intern  → @1004        │  ───┘
│ s2      → @1004        │  ───┐ 指向常量池对象
└─────────────────────────┘     └

执行流程:
1. x = "ab" → 常量池创建@1004
2. s1 = new String("a") + new String("b") → 堆中创建@1005
3. s1.intern() → 常量池中已有"ab"@1004，返回@1004
4. s2 = "ab" → 从常量池获取@1004引用
5. 结果: s1 != s2 (false), s2 == intern (true)
```

## 📊 **核心差异总结**

| 方法 | 关键区别 | intern()行为 | 结果 |
|------|----------|--------------|------|
| **demo01** | 字符串拼接不进常量池 | 将堆引用存入常量池 | `s1 == s2 == intern` |
| **demo02** | `new String("ab")`同时创建两个对象 | 返回已存在的常量池对象 | `s1 != s2 == intern` |
| **demo03** | 先在常量池创建字符串 | 返回已存在的常量池对象 | `s1 != s2 == intern` |

**关键理解：JDK1.7+的intern()不再复制对象，而是在常量池中存储堆对象的引用，这是性能优化的重要改进！**