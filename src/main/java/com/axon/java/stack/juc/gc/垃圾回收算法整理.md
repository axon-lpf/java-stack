# â™»ï¸ **Javaåƒåœ¾å›æ”¶ç®—æ³•è¯¦è§£ä¸æ‰©å±•**

## ğŸ“‹ **ç®—æ³•æ¦‚è§ˆå¯¹æ¯”è¡¨**

| ç®—æ³•åç§° | é€‚ç”¨åŒºåŸŸ | ä¸»è¦ä¼˜ç‚¹ | ä¸»è¦ç¼ºç‚¹ | ä½¿ç”¨åœºæ™¯ |
|----------|----------|----------|----------|----------|
| **å¼•ç”¨è®¡æ•°** | ç†è®ºç®—æ³• | å®æ—¶å›æ”¶ã€ç®€å• | å¾ªç¯å¼•ç”¨é—®é¢˜ | Pythonã€PHPç­‰ |
| **å¯è¾¾æ€§åˆ†æ** | æ ‡è®°é˜¶æ®µ | è§£å†³å¾ªç¯å¼•ç”¨ | éœ€è¦STW | æ‰€æœ‰ç°ä»£JVM |
| **æ ‡è®°æ¸…é™¤** | è€å¹´ä»£ | ä¸ç§»åŠ¨å¯¹è±¡ | å†…å­˜ç¢ç‰‡ | CMSã€Serial Old |
| **å¤åˆ¶ç®—æ³•** | å¹´è½»ä»£ | æ— ç¢ç‰‡ã€é«˜æ•ˆ | ç©ºé—´æµªè´¹50% | Serialã€ParNew |
| **åˆ†ä»£å›æ”¶** | å…¨å † | åˆ†ä»£ä¼˜åŒ– | ç®—æ³•å¤æ‚ | G1ã€ZGCã€Shenandoah |

---

## ğŸ”¢ **1. å¼•ç”¨è®¡æ•°ç®—æ³• (Reference Counting)**

### **ğŸ¯ æ ¸å¿ƒåŸç†**
ä¸ºæ¯ä¸ªå¯¹è±¡ç»´æŠ¤ä¸€ä¸ªå¼•ç”¨è®¡æ•°å™¨ï¼Œè®°å½•æŒ‡å‘è¯¥å¯¹è±¡çš„å¼•ç”¨æ•°é‡ã€‚

```java
// ğŸ” å¼•ç”¨è®¡æ•°ç¤ºä¾‹ï¼ˆä¼ªä»£ç ï¼‰
public class ReferenceCountingGC {
    private Object instance = null;
    private int refCount = 0; // å¼•ç”¨è®¡æ•°å™¨
    
    public void setReference(Object obj) {
        if (this.instance != null) {
            this.instance.refCount--; // å‡å°‘æ—§å¯¹è±¡å¼•ç”¨
        }
        this.instance = obj;
        if (obj != null) {
            obj.refCount++; // å¢åŠ æ–°å¯¹è±¡å¼•ç”¨
        }
    }
    
    // å½“refCountä¸º0æ—¶ï¼Œç«‹å³å›æ”¶
    public void gc() {
        if (refCount == 0) {
            // ç«‹å³é‡Šæ”¾å†…å­˜
            release();
        }
    }
}
```

### **âœ… ä¼˜ç‚¹**
- **å®æ—¶æ€§å¥½**ï¼šå¼•ç”¨ä¸º0æ—¶ç«‹å³å›æ”¶
- **ç®—æ³•ç®€å•**ï¼šæ˜“äºç†è§£å’Œå®ç°
- **æ— éœ€STW**ï¼šä¸éœ€è¦åœæ­¢æ‰€æœ‰çº¿ç¨‹

### **âŒ ç¼ºç‚¹**
- **å¾ªç¯å¼•ç”¨é—®é¢˜**ï¼šæ— æ³•å¤„ç†Aâ†’Bâ†’Açš„æƒ…å†µ
- **ç»´æŠ¤æˆæœ¬é«˜**ï¼šæ¯æ¬¡å¼•ç”¨å˜åŒ–éƒ½éœ€è¦æ›´æ–°è®¡æ•°å™¨
- **çº¿ç¨‹å®‰å…¨é—®é¢˜**ï¼šå¤šçº¿ç¨‹ç¯å¢ƒä¸‹è®¡æ•°å™¨æ“ä½œå¤æ‚

### **ğŸ”„ å¾ªç¯å¼•ç”¨é—®é¢˜æ¼”ç¤º**

```java
// âŒ å¾ªç¯å¼•ç”¨å¯¼è‡´å†…å­˜æ³„æ¼
public class CircularReference {
    private CircularReference reference;
    private byte[] data = new byte[1024 * 1024]; // 1MBæ•°æ®
    
    public static void main(String[] args) {
        CircularReference obj1 = new CircularReference();
        CircularReference obj2 = new CircularReference();
        
        // å½¢æˆå¾ªç¯å¼•ç”¨
        obj1.reference = obj2;
        obj2.reference = obj1;
        
        // å±€éƒ¨å˜é‡ç½®ç©º
        obj1 = null;
        obj2 = null;
        
        // ğŸš¨ å¼•ç”¨è®¡æ•°ç®—æ³•æ— æ³•å›æ”¶è¿™ä¸¤ä¸ªå¯¹è±¡
        // å› ä¸ºå®ƒä»¬çš„å¼•ç”¨è®¡æ•°éƒ½æ˜¯1ï¼ˆäº’ç›¸å¼•ç”¨ï¼‰
        System.gc(); // æ— æ•ˆ
    }
}
```

---

## ğŸ¯ **2. å¯è¾¾æ€§åˆ†æç®—æ³• (Reachability Analysis)**

### **ğŸ¯ æ ¸å¿ƒåŸç†**
ä»GC Rootså¼€å§‹å‘ä¸‹æœç´¢ï¼Œæœç´¢èµ°è¿‡çš„è·¯å¾„ç§°ä¸º**å¼•ç”¨é“¾**ï¼Œå½“ä¸€ä¸ªå¯¹è±¡åˆ°GC Rootsæ²¡æœ‰ä»»ä½•å¼•ç”¨é“¾ç›¸è¿æ—¶ï¼Œè¯æ˜æ­¤å¯¹è±¡ä¸å¯è¾¾ã€‚

```java
// ğŸ” å¯è¾¾æ€§åˆ†æç¤ºä¾‹
public class ReachabilityAnalysis {
    
    // ğŸ“ GC Roots åŒ…æ‹¬ï¼š
    // 1. è™šæ‹Ÿæœºæ ˆä¸­å¼•ç”¨çš„å¯¹è±¡
    // 2. æ–¹æ³•åŒºä¸­ç±»é™æ€å±æ€§å¼•ç”¨çš„å¯¹è±¡  
    // 3. æ–¹æ³•åŒºä¸­å¸¸é‡å¼•ç”¨çš„å¯¹è±¡
    // 4. JNIå¼•ç”¨çš„å¯¹è±¡
    // 5. Threadå¯¹è±¡
    // 6. åŒæ­¥é”æŒæœ‰çš„å¯¹è±¡
    
    private static Object staticReference;     // GC Root - é™æ€å˜é‡
    private Object instanceReference;          // å®ä¾‹å˜é‡
    
    public void demonstrateReachability() {
        Object localReference = new Object();  // GC Root - æ ˆå¸§å±€éƒ¨å˜é‡
        
        // ğŸ”— å¼•ç”¨é“¾ï¼šGC Root â†’ localReference â†’ Object
        // è¯¥å¯¹è±¡å¯è¾¾ï¼Œä¸ä¼šè¢«å›æ”¶
        
        localReference = null; // æ–­å¼€å¼•ç”¨é“¾
        // ç°åœ¨å¯¹è±¡ä¸å¯è¾¾ï¼Œå¯ä»¥è¢«å›æ”¶
        
        System.gc();
    }
    
    // ğŸ§ª æ¼”ç¤ºå¤æ‚å¼•ç”¨å…³ç³»
    public static void complexReachabilityDemo() {
        Node root = new Node("root");        // GC Root
        Node child1 = new Node("child1");
        Node child2 = new Node("child2");
        Node orphan = new Node("orphan");    // å­¤å„¿å¯¹è±¡
        
        // æ„å»ºå¼•ç”¨é“¾
        root.next = child1;
        child1.next = child2;
        // orphanæ²¡æœ‰è¢«ä»»ä½•GC Rootå¼•ç”¨
        
        System.gc(); // orphanä¼šè¢«å›æ”¶ï¼Œå…¶ä»–ä¸ä¼š
    }
    
    static class Node {
        String name;
        Node next;
        public Node(String name) { this.name = name; }
    }
}
```

### **ğŸ” GC Roots è¯¦è§£**

```java
// ğŸ“ å„ç§GC Rootsç¤ºä¾‹
public class GCRootsDemo {
    
    // 1ï¸âƒ£ é™æ€å˜é‡ - GC Root
    private static Object staticObj = new Object();
    
    // 2ï¸âƒ£ å¸¸é‡ - GC Root  
    private static final Object CONSTANT_OBJ = new Object();
    
    // 3ï¸âƒ£ ç±»å¯¹è±¡ - GC Root
    private static Class<?> clazz = String.class;
    
    public void methodDemo() {
        // 4ï¸âƒ£ å±€éƒ¨å˜é‡ - GC Rootï¼ˆåœ¨æ–¹æ³•æ‰§è¡ŒæœŸé—´ï¼‰
        Object localObj = new Object();
        
        // 5ï¸âƒ£ æ–¹æ³•å‚æ•° - GC Root
        processObject(new Object());
        
        // 6ï¸âƒ£ å¼‚å¸¸å¯¹è±¡ - GC Root
        try {
            throw new RuntimeException("test");
        } catch (Exception e) {
            // eæ˜¯GC Root
            System.out.println(e.getMessage());
        }
        
        // 7ï¸âƒ£ åŒæ­¥é” - GC Root
        Object lock = new Object();
        synchronized (lock) {
            // lockåœ¨åŒæ­¥æœŸé—´æ˜¯GC Root
        }
    }
    
    private void processObject(Object param) {
        // paramæ˜¯GC Root
    }
    
    // 8ï¸âƒ£ æ´»è·ƒçº¿ç¨‹ - GC Root
    public void threadDemo() {
        Thread thread = new Thread(() -> {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        thread.start(); // æ´»è·ƒçš„threadå¯¹è±¡æ˜¯GC Root
    }
}
```

---

## ğŸ§¹ **3. æ ‡è®°æ¸…é™¤ç®—æ³• (Mark-Sweep)**

### **ğŸ¯ ç®—æ³•æµç¨‹**
1. **æ ‡è®°é˜¶æ®µ**ï¼šä½¿ç”¨å¯è¾¾æ€§åˆ†ææ ‡è®°æ‰€æœ‰å¯è¾¾å¯¹è±¡
2. **æ¸…é™¤é˜¶æ®µ**ï¼šå›æ”¶æ‰€æœ‰æœªè¢«æ ‡è®°çš„å¯¹è±¡

```java
// ğŸ” æ ‡è®°æ¸…é™¤ç®—æ³•æ¨¡æ‹Ÿ
public class MarkSweepGC {
    
    private List<Object> heap = new ArrayList<>();
    private Set<Object> markedObjects = new HashSet<>();
    
    // ğŸ“ ç¬¬ä¸€é˜¶æ®µï¼šæ ‡è®°
    public void mark() {
        System.out.println("ğŸ·ï¸ å¼€å§‹æ ‡è®°é˜¶æ®µ...");
        
        // ä»GC Rootså¼€å§‹æ ‡è®°
        markFromGCRoots();
        
        System.out.println("âœ… æ ‡è®°å®Œæˆï¼Œæ ‡è®°å¯¹è±¡æ•°: " + markedObjects.size());
    }
    
    private void markFromGCRoots() {
        // æ¨¡æ‹Ÿä»GC Rootséå†å¯¹è±¡å›¾
        for (Object gcRoot : getGCRoots()) {
            markObject(gcRoot);
        }
    }
    
    private void markObject(Object obj) {
        if (obj == null || markedObjects.contains(obj)) {
            return;
        }
        
        markedObjects.add(obj);
        
        // é€’å½’æ ‡è®°æ‰€æœ‰å¯è¾¾å¯¹è±¡
        for (Object reference : getReferences(obj)) {
            markObject(reference);
        }
    }
    
    // ğŸ“ ç¬¬äºŒé˜¶æ®µï¼šæ¸…é™¤
    public void sweep() {
        System.out.println("ğŸ§¹ å¼€å§‹æ¸…é™¤é˜¶æ®µ...");
        
        Iterator<Object> iterator = heap.iterator();
        int collected = 0;
        
        while (iterator.hasNext()) {
            Object obj = iterator.next();
            
            // æ¸…é™¤æœªæ ‡è®°çš„å¯¹è±¡
            if (!markedObjects.contains(obj)) {
                iterator.remove();
                collected++;
                
                // æ¨¡æ‹Ÿå†…å­˜é‡Šæ”¾
                releaseMemory(obj);
            }
        }
        
        System.out.println("ğŸ—‘ï¸ æ¸…é™¤å®Œæˆï¼Œå›æ”¶å¯¹è±¡æ•°: " + collected);
        
        // æ¸…é™¤æ ‡è®°ï¼Œä¸ºä¸‹æ¬¡GCå‡†å¤‡
        markedObjects.clear();
    }
    
    // ğŸ”„ å®Œæ•´GCæµç¨‹
    public void gc() {
        System.out.println("ğŸš¨ å¼€å§‹GC - æ ‡è®°æ¸…é™¤ç®—æ³•");
        
        long startTime = System.currentTimeMillis();
        
        // Stop The World - æš‚åœæ‰€æœ‰åº”ç”¨çº¿ç¨‹
        pauseAllThreads();
        
        try {
            mark();   // æ ‡è®°é˜¶æ®µ
            sweep();  // æ¸…é™¤é˜¶æ®µ
        } finally {
            resumeAllThreads(); // æ¢å¤åº”ç”¨çº¿ç¨‹
        }
        
        long duration = System.currentTimeMillis() - startTime;
        System.out.println("âœ… GCå®Œæˆï¼Œè€—æ—¶: " + duration + "ms");
    }
    
    // è¾…åŠ©æ–¹æ³•
    private List<Object> getGCRoots() { /* è·å–GC Roots */ return new ArrayList<>(); }
    private List<Object> getReferences(Object obj) { /* è·å–å¯¹è±¡å¼•ç”¨ */ return new ArrayList<>(); }
    private void releaseMemory(Object obj) { /* é‡Šæ”¾å†…å­˜ */ }
    private void pauseAllThreads() { /* æš‚åœçº¿ç¨‹ */ }
    private void resumeAllThreads() { /* æ¢å¤çº¿ç¨‹ */ }
}
```

### **âœ… ä¼˜ç‚¹**
- **ä¸ç§»åŠ¨å¯¹è±¡**ï¼šå¯¹è±¡åœ°å€ä¸å˜ï¼Œå¼•ç”¨ä¸éœ€è¦æ›´æ–°
- **ç®—æ³•ç®€å•**ï¼šå®¹æ˜“ç†è§£å’Œå®ç°
- **é€‚åˆè€å¹´ä»£**ï¼šè€å¹´ä»£å¯¹è±¡å­˜æ´»ç‡é«˜ï¼Œæ ‡è®°æ¸…é™¤æ•ˆç‡ç›¸å¯¹è¾ƒé«˜

### **âŒ ç¼ºç‚¹**
- **å†…å­˜ç¢ç‰‡**ï¼šæ¸…é™¤åäº§ç”Ÿå¤§é‡ä¸è¿ç»­å†…å­˜ç‰‡æ®µ
- **STWæ—¶é—´é•¿**ï¼šæ ‡è®°å’Œæ¸…é™¤éƒ½éœ€è¦æš‚åœåº”ç”¨
- **åˆ†é…æ•ˆç‡ä½**ï¼šéœ€è¦ç»´æŠ¤ç©ºé—²åˆ—è¡¨

### **ğŸ” å†…å­˜ç¢ç‰‡é—®é¢˜æ¼”ç¤º**

```java
// ğŸš¨ å†…å­˜ç¢ç‰‡åŒ–é—®é¢˜
public class FragmentationDemo {

    public static void demonstrateFragmentation() {
        System.out.println("ğŸ“Š å†…å­˜ç¢ç‰‡åŒ–æ¼”ç¤º");

        // å‡è®¾å †å†…å­˜å¸ƒå±€ï¼ˆç®€åŒ–ï¼‰
        String memory = "AABBCCDDEE__FF__GG__HH"; // A,B,Cç­‰è¡¨ç¤ºå¯¹è±¡ï¼Œ_è¡¨ç¤ºç©ºé—²
        System.out.println("GCå‰: " + memory);

        // æ ‡è®°æ¸…é™¤åï¼ˆå‡è®¾B,D,F,Hè¢«å›æ”¶ï¼‰
        String afterGC = "AA__CC____EE____GG____";
        System.out.println("GCå: " + afterGC);

        System.out.println("ğŸ’” é—®é¢˜ï¼šæ— æ³•åˆ†é…8å­—èŠ‚çš„è¿ç»­å¯¹è±¡ï¼Œå°½ç®¡æ€»ç©ºé—²ç©ºé—´è¶³å¤Ÿ");

        // è§£å†³æ–¹æ¡ˆï¼šå†…å­˜æ•´ç†ï¼ˆä½†æ ‡è®°æ¸…é™¤ç®—æ³•ä¸åŒ…å«æ­¤æ­¥éª¤ï¼‰
        String afterCompact = "AACCEEGG________________";
        System.out.println("æ•´ç†å: " + afterCompact);
    }
}
```

---

## ğŸ“‹ **4. å¤åˆ¶ç®—æ³• (Copying)**

### **ğŸ¯ æ ¸å¿ƒåŸç†**
å°†å†…å­˜åˆ†ä¸ºä¸¤ä¸ªç›¸ç­‰åŒºåŸŸï¼Œæ¯æ¬¡åªä½¿ç”¨å…¶ä¸­ä¸€ä¸ªã€‚GCæ—¶å°†å­˜æ´»å¯¹è±¡å¤åˆ¶åˆ°å¦ä¸€ä¸ªåŒºåŸŸï¼Œç„¶åæ¸…ç©ºå½“å‰åŒºåŸŸã€‚

```java
// ğŸ” å¤åˆ¶ç®—æ³•æ¨¡æ‹Ÿ
public class CopyingGC {
    
    // ğŸ  ä¸¤ä¸ªåŠåŒº
    private Object[] fromSpace;  // å½“å‰ä½¿ç”¨åŒºåŸŸ
    private Object[] toSpace;    // ç›®æ ‡åŒºåŸŸ
    
    private int fromPointer = 0;  // fromåŒºåˆ†é…æŒ‡é’ˆ
    private int toPointer = 0;    // toåŒºå¤åˆ¶æŒ‡é’ˆ
    
    public CopyingGC(int heapSize) {
        // å †å†…å­˜ä¸€åˆ†ä¸ºäºŒ
        fromSpace = new Object[heapSize / 2];
        toSpace = new Object[heapSize / 2];
    }
    
    // ğŸ“ å¯¹è±¡åˆ†é…
    public boolean allocate(Object obj) {
        if (fromPointer >= fromSpace.length) {
            // ç©ºé—´ä¸è¶³ï¼Œè§¦å‘GC
            return gc() && allocate(obj);
        }
        
        fromSpace[fromPointer++] = obj;
        return true;
    }
    
    // ğŸ“ å¤åˆ¶ç®—æ³•GCæµç¨‹
    public boolean gc() {
        System.out.println("ğŸ”„ å¼€å§‹å¤åˆ¶ç®—æ³•GC");
        
        long startTime = System.currentTimeMillis();
        toPointer = 0; // é‡ç½®toåŒºæŒ‡é’ˆ
        
        // ğŸ·ï¸ ç¬¬ä¸€é˜¶æ®µï¼šä»GC Rootså¼€å§‹éå†å¹¶å¤åˆ¶å­˜æ´»å¯¹è±¡
        for (Object gcRoot : getGCRoots()) {
            copyReachableObjects(gcRoot);
        }
        
        // ğŸ”„ ç¬¬äºŒé˜¶æ®µï¼šäº¤æ¢fromå’ŒtoåŒºåŸŸ
        Object[] temp = fromSpace;
        fromSpace = toSpace;
        toSpace = temp;
        
        // æ›´æ–°æŒ‡é’ˆ
        fromPointer = toPointer;
        
        long duration = System.currentTimeMillis() - startTime;
        System.out.println("âœ… å¤åˆ¶å®Œæˆï¼Œå­˜æ´»å¯¹è±¡: " + toPointer + "ï¼Œè€—æ—¶: " + duration + "ms");
        
        return fromPointer < fromSpace.length;
    }
    
    private void copyReachableObjects(Object obj) {
        if (obj == null || isAlreadyCopied(obj)) return;
        
        // å¤åˆ¶å¯¹è±¡åˆ°toåŒº
        toSpace[toPointer++] = obj;
        markAsCopied(obj);
        
        // é€’å½’å¤åˆ¶å¼•ç”¨çš„å¯¹è±¡
        for (Object reference : getReferences(obj)) {
            copyReachableObjects(reference);
        }
    }
}
```

### **âœ… ä¼˜ç‚¹**
- **æ— å†…å­˜ç¢ç‰‡**ï¼šç›®æ ‡åŒºåŸŸå¯¹è±¡ç´§å¯†æ’åˆ—
- **åˆ†é…é«˜æ•ˆ**ï¼šç®€å•çš„æŒ‡é’ˆé€’å¢åˆ†é…
- **å¹´è½»ä»£é€‚ç”¨**ï¼šå¹´è½»ä»£å­˜æ´»ç‡ä½ï¼Œå¤åˆ¶å¯¹è±¡å°‘

### **âŒ ç¼ºç‚¹**
- **ç©ºé—´æµªè´¹**ï¼šå§‹ç»ˆæœ‰50%å†…å­˜é—²ç½®
- **å¤åˆ¶å¼€é”€**ï¼šéœ€è¦å¤åˆ¶æ‰€æœ‰å­˜æ´»å¯¹è±¡
- **ä¸é€‚åˆè€å¹´ä»£**ï¼šè€å¹´ä»£å­˜æ´»ç‡é«˜ï¼Œå¤åˆ¶æˆæœ¬å¤§

---

## ğŸ—ï¸ **5. åˆ†ä»£å›æ”¶ç®—æ³• (Generational GC)**

### **ğŸ¯ æ ¸å¿ƒç†å¿µ**
åŸºäº**å¼±åˆ†ä»£å‡è¯´**ï¼šå¤§å¤šæ•°å¯¹è±¡æœç”Ÿå¤•æ­»ï¼Œå­˜æ´»æ—¶é—´é•¿çš„å¯¹è±¡è¶Šéš¾æ­»äº¡ã€‚

```java
// ğŸ” åˆ†ä»£å›æ”¶ç®—æ³•æ¼”ç¤ºï¼ˆG1ä¸ºä¾‹ï¼‰
public class GenerationalGC {
    
    // ğŸ  å†…å­˜åŒºåŸŸåˆ’åˆ†
    private YoungGeneration youngGen;    // å¹´è½»ä»£
    private OldGeneration oldGen;        // è€å¹´ä»£
    private MetaspaceGeneration metaspace; // å…ƒç©ºé—´
    
    public class YoungGeneration {
        private Region eden;      // EdenåŒº - 80%
        private Region survivor1; // Survivor1åŒº - 10%  
        private Region survivor2; // Survivor2åŒº - 10%
        
        // ğŸ”„ Minor GC - å¤åˆ¶ç®—æ³•
        public void minorGC() {
            System.out.println("ğŸŒ± æ‰§è¡ŒMinor GCï¼ˆå¹´è½»ä»£ï¼‰");
            
            // Eden + Survivor1 â†’ Survivor2
            copyAliveObjects(eden, survivor2);
            copyAliveObjects(survivor1, survivor2);
            
            // å¹´é¾„è¶…è¿‡é˜ˆå€¼çš„å¯¹è±¡æ™‹å‡åˆ°è€å¹´ä»£
            promoteToOldGen();
            
            // æ¸…ç©ºEdenå’ŒSurvivor1
            eden.clear();
            survivor1.clear();
            
            // äº¤æ¢ä¸¤ä¸ªSurvivoråŒº
            Region temp = survivor1;
            survivor1 = survivor2;
            survivor2 = temp;
        }
    }
    
    public class OldGeneration {
        private List<Region> regions;
        
        // ğŸ”„ Major GC - æ ‡è®°æ¸…é™¤æˆ–æ ‡è®°æ•´ç†
        public void majorGC() {
            System.out.println("ğŸ›ï¸ æ‰§è¡ŒMajor GCï¼ˆè€å¹´ä»£ï¼‰");
            
            // ä½¿ç”¨æ ‡è®°æ¸…é™¤ç®—æ³•
            markSweepGC();
            
            // æˆ–ä½¿ç”¨æ ‡è®°æ•´ç†ç®—æ³•
            // markCompactGC();
        }
        
        private void markSweepGC() {
            // æ ‡è®°é˜¶æ®µ
            markReachableObjects();
            
            // æ¸…é™¤é˜¶æ®µ
            sweepUnreachableObjects();
        }
    }
    
    // ğŸ¯ G1 GCç‰¹ç‚¹
    public void g1GCDemo() {
        System.out.println("ğŸ”„ G1 GC æ‰§è¡Œæµç¨‹");
        
        // 1. å¹´è½»ä»£æ”¶é›†ï¼ˆEvacuation Pauseï¼‰
        youngGen.minorGC();
        
        // 2. å¹¶å‘æ ‡è®°å‘¨æœŸ
        concurrentMarkingCycle();
        
        // 3. æ··åˆæ”¶é›†ï¼ˆMixed GCï¼‰
        mixedGC();
        
        // 4. Full GCï¼ˆG1å°½é‡é¿å…ï¼‰
        if (needFullGC()) {
            fullGC();
        }
    }
    
    private void concurrentMarkingCycle() {
        System.out.println("ğŸ·ï¸ å¹¶å‘æ ‡è®°å‘¨æœŸå¼€å§‹");
        // ä¸åº”ç”¨çº¿ç¨‹å¹¶è¡Œæ‰§è¡Œ
    }
    
    private void mixedGC() {
        System.out.println("ğŸ”€ æ··åˆæ”¶é›†ï¼šæ¸…ç†éƒ¨åˆ†è€å¹´ä»£Region");
        // æ”¶é›†å¹´è½»ä»£ + éƒ¨åˆ†è€å¹´ä»£
    }
}
```

---

## ğŸ“Š **ç®—æ³•é€‰æ‹©ç­–ç•¥ä¸æœ€ä½³å®è·µ**

### **ğŸ¯ JVMåƒåœ¾æ”¶é›†å™¨å¯¹åº”å…³ç³»**

```java
// ğŸ”§ ä¸åŒåƒåœ¾æ”¶é›†å™¨ä½¿ç”¨çš„ç®—æ³•
public class GCCollectors {
    
    // Serial GC
    // å¹´è½»ä»£ï¼šå¤åˆ¶ç®—æ³•ï¼Œè€å¹´ä»£ï¼šæ ‡è®°æ¸…é™¤
    
    // Parallel GC  
    // å¹´è½»ä»£ï¼šå¤åˆ¶ç®—æ³•ï¼Œè€å¹´ä»£ï¼šæ ‡è®°æ•´ç†
    
    // CMS GC
    // å¹´è½»ä»£ï¼šå¤åˆ¶ç®—æ³•ï¼Œè€å¹´ä»£ï¼šæ ‡è®°æ¸…é™¤
    
    // G1 GC
    // ç»Ÿä¸€ä½¿ç”¨å¤åˆ¶ç®—æ³•ï¼Œåˆ†Regionç®¡ç†
    
    // ZGC / Shenandoah
    // åŸºäºRegionçš„å¹¶å‘å¤åˆ¶ç®—æ³•
}
```

### **âš™ï¸ è°ƒä¼˜å‚æ•°å»ºè®®**

```bash
# ğŸ›ï¸ å¸¸ç”¨GCè°ƒä¼˜å‚æ•°
-XX:+UseG1GC                    # ä½¿ç”¨G1åƒåœ¾æ”¶é›†å™¨
-XX:MaxGCPauseMillis=200        # æœ€å¤§GCæš‚åœæ—¶é—´
-XX:G1HeapRegionSize=16m        # G1 Regionå¤§å°
-XX:+G1UseAdaptiveIHOP          # è‡ªé€‚åº”è°ƒæ•´å¹¶å‘å‘¨æœŸ
-XX:NewRatio=2                  # å¹´è½»ä»£ä¸è€å¹´ä»£æ¯”ä¾‹
-XX:SurvivorRatio=8             # Edenä¸Survivoræ¯”ä¾‹
-XX:MaxTenuringThreshold=15     # å¯¹è±¡æ™‹å‡å¹´é¾„é˜ˆå€¼
```

## ğŸ¯ **æ€»ç»“ä¸å»ºè®®**

### **ğŸ“‹ ç®—æ³•é€‰æ‹©æŒ‡å—**

| åœºæ™¯ç‰¹å¾ | æ¨èç®—æ³• | é€‚ç”¨æ”¶é›†å™¨ |
|----------|----------|------------|
| **é«˜ååé‡åº”ç”¨** | æ ‡è®°æ•´ç† + å¤åˆ¶ | Parallel GC |
| **ä½å»¶è¿Ÿåº”ç”¨** | å¹¶å‘å¤åˆ¶ | G1ã€ZGCã€Shenandoah |
| **å°å †å†…å­˜** | æ ‡è®°æ¸…é™¤ + å¤åˆ¶ | Serial GC |
| **å¤§å †å†…å­˜** | åˆ†ä»£ + å¹¶å‘ | G1ã€ZGC |

### **ğŸ† ç°ä»£GCå‘å±•è¶‹åŠ¿**
- **ä½å»¶è¿Ÿä¼˜å…ˆ**ï¼šZGCã€Shenandoahè¿½æ±‚äºšæ¯«ç§’çº§æš‚åœ
- **å¹¶å‘ä¼˜åŒ–**ï¼šå‡å°‘STWæ—¶é—´ï¼Œæé«˜ç”¨æˆ·ä½“éªŒ
- **è‡ªé€‚åº”è°ƒä¼˜**ï¼šæ™ºèƒ½å‚æ•°è°ƒæ•´ï¼Œé™ä½è¿ç»´æˆæœ¬
- **å†…å­˜ç®¡ç†ä¼˜åŒ–**ï¼šRegionåŒ–ç®¡ç†ï¼Œç²¾ç»†æ§åˆ¶

**å»ºè®®ï¼šç”Ÿäº§ç¯å¢ƒä¼˜å…ˆé€‰æ‹©G1 GCï¼Œå®ƒå¹³è¡¡äº†ååé‡å’Œå»¶è¿Ÿï¼Œæ˜¯å½“å‰æœ€æˆç†Ÿçš„ä½å»¶è¿Ÿåƒåœ¾æ”¶é›†å™¨ã€‚**