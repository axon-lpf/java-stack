# ♻️ **Java垃圾回收算法详解与扩展**

## 📋 **算法概览对比表**

| 算法名称 | 适用区域 | 主要优点 | 主要缺点 | 使用场景 |
|----------|----------|----------|----------|----------|
| **引用计数** | 理论算法 | 实时回收、简单 | 循环引用问题 | Python、PHP等 |
| **可达性分析** | 标记阶段 | 解决循环引用 | 需要STW | 所有现代JVM |
| **标记清除** | 老年代 | 不移动对象 | 内存碎片 | CMS、Serial Old |
| **复制算法** | 年轻代 | 无碎片、高效 | 空间浪费50% | Serial、ParNew |
| **分代回收** | 全堆 | 分代优化 | 算法复杂 | G1、ZGC、Shenandoah |

---

## 🔢 **1. 引用计数算法 (Reference Counting)**

### **🎯 核心原理**
为每个对象维护一个引用计数器，记录指向该对象的引用数量。

```java
// 🔍 引用计数示例（伪代码）
public class ReferenceCountingGC {
    private Object instance = null;
    private int refCount = 0; // 引用计数器
    
    public void setReference(Object obj) {
        if (this.instance != null) {
            this.instance.refCount--; // 减少旧对象引用
        }
        this.instance = obj;
        if (obj != null) {
            obj.refCount++; // 增加新对象引用
        }
    }
    
    // 当refCount为0时，立即回收
    public void gc() {
        if (refCount == 0) {
            // 立即释放内存
            release();
        }
    }
}
```

### **✅ 优点**
- **实时性好**：引用为0时立即回收
- **算法简单**：易于理解和实现
- **无需STW**：不需要停止所有线程

### **❌ 缺点**
- **循环引用问题**：无法处理A→B→A的情况
- **维护成本高**：每次引用变化都需要更新计数器
- **线程安全问题**：多线程环境下计数器操作复杂

### **🔄 循环引用问题演示**

```java
// ❌ 循环引用导致内存泄漏
public class CircularReference {
    private CircularReference reference;
    private byte[] data = new byte[1024 * 1024]; // 1MB数据
    
    public static void main(String[] args) {
        CircularReference obj1 = new CircularReference();
        CircularReference obj2 = new CircularReference();
        
        // 形成循环引用
        obj1.reference = obj2;
        obj2.reference = obj1;
        
        // 局部变量置空
        obj1 = null;
        obj2 = null;
        
        // 🚨 引用计数算法无法回收这两个对象
        // 因为它们的引用计数都是1（互相引用）
        System.gc(); // 无效
    }
}
```

---

## 🎯 **2. 可达性分析算法 (Reachability Analysis)**

### **🎯 核心原理**
从GC Roots开始向下搜索，搜索走过的路径称为**引用链**，当一个对象到GC Roots没有任何引用链相连时，证明此对象不可达。

```java
// 🔍 可达性分析示例
public class ReachabilityAnalysis {
    
    // 📍 GC Roots 包括：
    // 1. 虚拟机栈中引用的对象
    // 2. 方法区中类静态属性引用的对象  
    // 3. 方法区中常量引用的对象
    // 4. JNI引用的对象
    // 5. Thread对象
    // 6. 同步锁持有的对象
    
    private static Object staticReference;     // GC Root - 静态变量
    private Object instanceReference;          // 实例变量
    
    public void demonstrateReachability() {
        Object localReference = new Object();  // GC Root - 栈帧局部变量
        
        // 🔗 引用链：GC Root → localReference → Object
        // 该对象可达，不会被回收
        
        localReference = null; // 断开引用链
        // 现在对象不可达，可以被回收
        
        System.gc();
    }
    
    // 🧪 演示复杂引用关系
    public static void complexReachabilityDemo() {
        Node root = new Node("root");        // GC Root
        Node child1 = new Node("child1");
        Node child2 = new Node("child2");
        Node orphan = new Node("orphan");    // 孤儿对象
        
        // 构建引用链
        root.next = child1;
        child1.next = child2;
        // orphan没有被任何GC Root引用
        
        System.gc(); // orphan会被回收，其他不会
    }
    
    static class Node {
        String name;
        Node next;
        public Node(String name) { this.name = name; }
    }
}
```

### **🔍 GC Roots 详解**

```java
// 📍 各种GC Roots示例
public class GCRootsDemo {
    
    // 1️⃣ 静态变量 - GC Root
    private static Object staticObj = new Object();
    
    // 2️⃣ 常量 - GC Root  
    private static final Object CONSTANT_OBJ = new Object();
    
    // 3️⃣ 类对象 - GC Root
    private static Class<?> clazz = String.class;
    
    public void methodDemo() {
        // 4️⃣ 局部变量 - GC Root（在方法执行期间）
        Object localObj = new Object();
        
        // 5️⃣ 方法参数 - GC Root
        processObject(new Object());
        
        // 6️⃣ 异常对象 - GC Root
        try {
            throw new RuntimeException("test");
        } catch (Exception e) {
            // e是GC Root
            System.out.println(e.getMessage());
        }
        
        // 7️⃣ 同步锁 - GC Root
        Object lock = new Object();
        synchronized (lock) {
            // lock在同步期间是GC Root
        }
    }
    
    private void processObject(Object param) {
        // param是GC Root
    }
    
    // 8️⃣ 活跃线程 - GC Root
    public void threadDemo() {
        Thread thread = new Thread(() -> {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        thread.start(); // 活跃的thread对象是GC Root
    }
}
```

---

## 🧹 **3. 标记清除算法 (Mark-Sweep)**

### **🎯 算法流程**
1. **标记阶段**：使用可达性分析标记所有可达对象
2. **清除阶段**：回收所有未被标记的对象

```java
// 🔍 标记清除算法模拟
public class MarkSweepGC {
    
    private List<Object> heap = new ArrayList<>();
    private Set<Object> markedObjects = new HashSet<>();
    
    // 📍 第一阶段：标记
    public void mark() {
        System.out.println("🏷️ 开始标记阶段...");
        
        // 从GC Roots开始标记
        markFromGCRoots();
        
        System.out.println("✅ 标记完成，标记对象数: " + markedObjects.size());
    }
    
    private void markFromGCRoots() {
        // 模拟从GC Roots遍历对象图
        for (Object gcRoot : getGCRoots()) {
            markObject(gcRoot);
        }
    }
    
    private void markObject(Object obj) {
        if (obj == null || markedObjects.contains(obj)) {
            return;
        }
        
        markedObjects.add(obj);
        
        // 递归标记所有可达对象
        for (Object reference : getReferences(obj)) {
            markObject(reference);
        }
    }
    
    // 📍 第二阶段：清除
    public void sweep() {
        System.out.println("🧹 开始清除阶段...");
        
        Iterator<Object> iterator = heap.iterator();
        int collected = 0;
        
        while (iterator.hasNext()) {
            Object obj = iterator.next();
            
            // 清除未标记的对象
            if (!markedObjects.contains(obj)) {
                iterator.remove();
                collected++;
                
                // 模拟内存释放
                releaseMemory(obj);
            }
        }
        
        System.out.println("🗑️ 清除完成，回收对象数: " + collected);
        
        // 清除标记，为下次GC准备
        markedObjects.clear();
    }
    
    // 🔄 完整GC流程
    public void gc() {
        System.out.println("🚨 开始GC - 标记清除算法");
        
        long startTime = System.currentTimeMillis();
        
        // Stop The World - 暂停所有应用线程
        pauseAllThreads();
        
        try {
            mark();   // 标记阶段
            sweep();  // 清除阶段
        } finally {
            resumeAllThreads(); // 恢复应用线程
        }
        
        long duration = System.currentTimeMillis() - startTime;
        System.out.println("✅ GC完成，耗时: " + duration + "ms");
    }
    
    // 辅助方法
    private List<Object> getGCRoots() { /* 获取GC Roots */ return new ArrayList<>(); }
    private List<Object> getReferences(Object obj) { /* 获取对象引用 */ return new ArrayList<>(); }
    private void releaseMemory(Object obj) { /* 释放内存 */ }
    private void pauseAllThreads() { /* 暂停线程 */ }
    private void resumeAllThreads() { /* 恢复线程 */ }
}
```

### **✅ 优点**
- **不移动对象**：对象地址不变，引用不需要更新
- **算法简单**：容易理解和实现
- **适合老年代**：老年代对象存活率高，标记清除效率相对较高

### **❌ 缺点**
- **内存碎片**：清除后产生大量不连续内存片段
- **STW时间长**：标记和清除都需要暂停应用
- **分配效率低**：需要维护空闲列表

### **🔍 内存碎片问题演示**

```java
// 🚨 内存碎片化问题
public class FragmentationDemo {

    public static void demonstrateFragmentation() {
        System.out.println("📊 内存碎片化演示");

        // 假设堆内存布局（简化）
        String memory = "AABBCCDDEE__FF__GG__HH"; // A,B,C等表示对象，_表示空闲
        System.out.println("GC前: " + memory);

        // 标记清除后（假设B,D,F,H被回收）
        String afterGC = "AA__CC____EE____GG____";
        System.out.println("GC后: " + afterGC);

        System.out.println("💔 问题：无法分配8字节的连续对象，尽管总空闲空间足够");

        // 解决方案：内存整理（但标记清除算法不包含此步骤）
        String afterCompact = "AACCEEGG________________";
        System.out.println("整理后: " + afterCompact);
    }
}
```

---

## 📋 **4. 复制算法 (Copying)**

### **🎯 核心原理**
将内存分为两个相等区域，每次只使用其中一个。GC时将存活对象复制到另一个区域，然后清空当前区域。

```java
// 🔍 复制算法模拟
public class CopyingGC {
    
    // 🏠 两个半区
    private Object[] fromSpace;  // 当前使用区域
    private Object[] toSpace;    // 目标区域
    
    private int fromPointer = 0;  // from区分配指针
    private int toPointer = 0;    // to区复制指针
    
    public CopyingGC(int heapSize) {
        // 堆内存一分为二
        fromSpace = new Object[heapSize / 2];
        toSpace = new Object[heapSize / 2];
    }
    
    // 📍 对象分配
    public boolean allocate(Object obj) {
        if (fromPointer >= fromSpace.length) {
            // 空间不足，触发GC
            return gc() && allocate(obj);
        }
        
        fromSpace[fromPointer++] = obj;
        return true;
    }
    
    // 📍 复制算法GC流程
    public boolean gc() {
        System.out.println("🔄 开始复制算法GC");
        
        long startTime = System.currentTimeMillis();
        toPointer = 0; // 重置to区指针
        
        // 🏷️ 第一阶段：从GC Roots开始遍历并复制存活对象
        for (Object gcRoot : getGCRoots()) {
            copyReachableObjects(gcRoot);
        }
        
        // 🔄 第二阶段：交换from和to区域
        Object[] temp = fromSpace;
        fromSpace = toSpace;
        toSpace = temp;
        
        // 更新指针
        fromPointer = toPointer;
        
        long duration = System.currentTimeMillis() - startTime;
        System.out.println("✅ 复制完成，存活对象: " + toPointer + "，耗时: " + duration + "ms");
        
        return fromPointer < fromSpace.length;
    }
    
    private void copyReachableObjects(Object obj) {
        if (obj == null || isAlreadyCopied(obj)) return;
        
        // 复制对象到to区
        toSpace[toPointer++] = obj;
        markAsCopied(obj);
        
        // 递归复制引用的对象
        for (Object reference : getReferences(obj)) {
            copyReachableObjects(reference);
        }
    }
}
```

### **✅ 优点**
- **无内存碎片**：目标区域对象紧密排列
- **分配高效**：简单的指针递增分配
- **年轻代适用**：年轻代存活率低，复制对象少

### **❌ 缺点**
- **空间浪费**：始终有50%内存闲置
- **复制开销**：需要复制所有存活对象
- **不适合老年代**：老年代存活率高，复制成本大

---

## 🏗️ **5. 分代回收算法 (Generational GC)**

### **🎯 核心理念**
基于**弱分代假说**：大多数对象朝生夕死，存活时间长的对象越难死亡。

```java
// 🔍 分代回收算法演示（G1为例）
public class GenerationalGC {
    
    // 🏠 内存区域划分
    private YoungGeneration youngGen;    // 年轻代
    private OldGeneration oldGen;        // 老年代
    private MetaspaceGeneration metaspace; // 元空间
    
    public class YoungGeneration {
        private Region eden;      // Eden区 - 80%
        private Region survivor1; // Survivor1区 - 10%  
        private Region survivor2; // Survivor2区 - 10%
        
        // 🔄 Minor GC - 复制算法
        public void minorGC() {
            System.out.println("🌱 执行Minor GC（年轻代）");
            
            // Eden + Survivor1 → Survivor2
            copyAliveObjects(eden, survivor2);
            copyAliveObjects(survivor1, survivor2);
            
            // 年龄超过阈值的对象晋升到老年代
            promoteToOldGen();
            
            // 清空Eden和Survivor1
            eden.clear();
            survivor1.clear();
            
            // 交换两个Survivor区
            Region temp = survivor1;
            survivor1 = survivor2;
            survivor2 = temp;
        }
    }
    
    public class OldGeneration {
        private List<Region> regions;
        
        // 🔄 Major GC - 标记清除或标记整理
        public void majorGC() {
            System.out.println("🏛️ 执行Major GC（老年代）");
            
            // 使用标记清除算法
            markSweepGC();
            
            // 或使用标记整理算法
            // markCompactGC();
        }
        
        private void markSweepGC() {
            // 标记阶段
            markReachableObjects();
            
            // 清除阶段
            sweepUnreachableObjects();
        }
    }
    
    // 🎯 G1 GC特点
    public void g1GCDemo() {
        System.out.println("🔄 G1 GC 执行流程");
        
        // 1. 年轻代收集（Evacuation Pause）
        youngGen.minorGC();
        
        // 2. 并发标记周期
        concurrentMarkingCycle();
        
        // 3. 混合收集（Mixed GC）
        mixedGC();
        
        // 4. Full GC（G1尽量避免）
        if (needFullGC()) {
            fullGC();
        }
    }
    
    private void concurrentMarkingCycle() {
        System.out.println("🏷️ 并发标记周期开始");
        // 与应用线程并行执行
    }
    
    private void mixedGC() {
        System.out.println("🔀 混合收集：清理部分老年代Region");
        // 收集年轻代 + 部分老年代
    }
}
```

---

## 📊 **算法选择策略与最佳实践**

### **🎯 JVM垃圾收集器对应关系**

```java
// 🔧 不同垃圾收集器使用的算法
public class GCCollectors {
    
    // Serial GC
    // 年轻代：复制算法，老年代：标记清除
    
    // Parallel GC  
    // 年轻代：复制算法，老年代：标记整理
    
    // CMS GC
    // 年轻代：复制算法，老年代：标记清除
    
    // G1 GC
    // 统一使用复制算法，分Region管理
    
    // ZGC / Shenandoah
    // 基于Region的并发复制算法
}
```

### **⚙️ 调优参数建议**

```bash
# 🎛️ 常用GC调优参数
-XX:+UseG1GC                    # 使用G1垃圾收集器
-XX:MaxGCPauseMillis=200        # 最大GC暂停时间
-XX:G1HeapRegionSize=16m        # G1 Region大小
-XX:+G1UseAdaptiveIHOP          # 自适应调整并发周期
-XX:NewRatio=2                  # 年轻代与老年代比例
-XX:SurvivorRatio=8             # Eden与Survivor比例
-XX:MaxTenuringThreshold=15     # 对象晋升年龄阈值
```

## 🎯 **总结与建议**

### **📋 算法选择指南**

| 场景特征 | 推荐算法 | 适用收集器 |
|----------|----------|------------|
| **高吞吐量应用** | 标记整理 + 复制 | Parallel GC |
| **低延迟应用** | 并发复制 | G1、ZGC、Shenandoah |
| **小堆内存** | 标记清除 + 复制 | Serial GC |
| **大堆内存** | 分代 + 并发 | G1、ZGC |

### **🏆 现代GC发展趋势**
- **低延迟优先**：ZGC、Shenandoah追求亚毫秒级暂停
- **并发优化**：减少STW时间，提高用户体验
- **自适应调优**：智能参数调整，降低运维成本
- **内存管理优化**：Region化管理，精细控制

**建议：生产环境优先选择G1 GC，它平衡了吞吐量和延迟，是当前最成熟的低延迟垃圾收集器。**