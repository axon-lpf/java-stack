reactor 有三种模式

1.单reactor单线程处理

2.单reactor多线程处理

3.主从reactor多线程处理
   主reactor, 多个subReactor  还有业务handler

4.传统的io模式

以上四种模式的理解，可以运用生活场景对应起来， 我们去入住酒店，酒店大门口有接待员， 然后带你去到指定的地方找指定的前台经理办理入住，登记办理完手续后，有对应的服务员带你去到客房。

1>.单reactor单线程处理
  场景： 相当接待员，不经做了自己本分的事情，还做了前台经理的工作，也做了服务员的工作。 但是这个接待员也可以同时接待多个客户，如果客户多了，让客户排队，不会拒绝，等到上一个办理完，再接着处理。
  实际： reactor 接收到链接请求，去做了对应读取、业务处理等相关工作，  单个reactor可以接收多个请求，让其排队处理。

2>单reactor多线程处理
  场景： 接待员，接到客户，交给指定前台经理办理入住，前台经理登记完信息后，并带到客房。（有多个前台经理）
  实际： reactor 接收到链接请求， 并转到对应的线程去处理。然后自己持续接收新的请求。

3>主从reactor多线程处理
  场景： 接待员，接到客户，交给指定前台经理办理入住, 登记完信息后，交给服务生带到客房。 （这里的接待员有多个， 前台经理有多个， 服务生有多个）
  实际： reactor 接收到链接请求， 分配给指定的subReactor去处理，读取信息。 然后再交给指定的线程去处理业务信息

4>传统的io模式
  场景：即每个接待员同时只能接待一位客户，帮其登记信息，带领到客房，只能等上一个任务完全完成了，才能去接收其它的客户。 我们的接待员是有限的，假如只有三个，
 一旦大于三个后，则无法接收，只能拒绝客户。这样就造成了客户的流失。
  实际：一个请求占用一个线程链接， 服务器的线程有限，超过特定的数量，则无法接收新的请求，响应500.

netty中使用了第三种模式，达到了高并发模式。



chatGpt总结

1. 单 Reactor 单线程处理

	•	场景类比：接待员负责一切。他接待客户、办理入住、带客户到房间。接待员虽然可以同时处理多个客户，但由于他一个人负责所有工作，客户需要排队。
	•	实际情况：单个 Reactor 负责所有的事件处理：监听、读取数据、业务处理等。如果客户多，事件排队处理。由于单线程限制，处理大量并发连接时性能会受到严重影响。
	•	图解：
        客户请求 --> 接待员(Reactor) --> 自己处理所有工作（接待、登记、带到客房）

2. 单 Reactor 多线程处理

	•	场景类比：接待员负责接待客户，然后把客户交给多个前台经理。前台经理负责办理入住。客户入住后服务员（线程池）带领客户到房间。
	•	实际情况：Reactor 接收连接请求，分发给多个工作线程处理具体的业务逻辑。Reactor 只负责接收请求，业务逻辑由多个线程并行处理。
	•	图解：
        客户请求 --> 接待员(Reactor) --> 多个前台经理(工作线程池) 处理具体事务 --> 线程池带到客房

3. 主从 Reactor 多线程处理

	•	场景类比：多个接待员接待客户，然后将客户分配给多个前台经理，前台经理登记后再交给服务员带到房间。这是最灵活和高效的模型。
	•	实际情况：主 Reactor 专门负责接收客户端连接，并将这些连接分发给子 Reactor。子 Reactor 负责管理这些连接并处理读写操作。多个工作线程处理实际的业务逻辑，形成高并发处理能力。
	•	图解：
	    客户请求 --> 主接待员(Main Reactor) --> 分发给多个前台经理(Sub Reactors) --> 线程池处理具体业务

4. 传统 IO 模式

	•	场景类比：每个接待员只能一次接待一个客户。他帮客户办理入住并亲自带领客户到房间。在完成之前，其他客户必须等待。由于接待员有限，超过一定数量的客户只能被拒绝。
	•	实际情况：每个连接请求占用一个线程，并且线程被阻塞直到任务完成。系统的线程数有限，无法应对大量并发请求。
	•	图解：
	    客户请求 --> 接待员(一个线程) --> 接待、处理、带到客房 (完成所有任务后才能接下一个)



1.	单 Reactor 单线程：适用于少量并发场景，单个线程处理一切工作，性能低。
2.	单 Reactor 多线程：适合适中并发的场景，Reactor 负责接收请求: 线程池处理业务。
3.	主从 Reactor 多线程：最佳的高并发解决方案，主 Reactor 负责连接分发，子 Reactor 和线程池分工处理，扩展性强。
4.	传统 IO 模式：每个请求占用一个线程，线程阻塞式操作，无法支持高并发。

   1. 单 Reactor 单线程：
    [Client 1] -> [Reactor]
    [Client 2] -> [Reactor]
    [Client 3] -> [Reactor]

    Reactor 处理所有请求，客户排队等待。

   2. 单 Reactor 多线程：
    [Client 1] -> [Reactor] -> [Thread 1]
    [Client 2] -> [Reactor] -> [Thread 2]
    [Client 3] -> [Reactor] -> [Thread 3]

    Reactor 负责分发任务，线程池处理请求。

   3.主从 Reactor 多线程：

             Main Reactor
            /      |      \
       Sub Reactor 1   Sub Reactor 2   Sub Reactor 3
          |              |              |
    [Thread 1]      [Thread 2]      [Thread 3]

    主 Reactor 分发请求，子 Reactor 管理读写，线程池处理业务。

    4.传统 IO 模式：
    [Client 1] -> [Thread 1] (waiting...)
    [Client 2] -> [Thread 2] (waiting...)
    [Client 3] -> [Thread 3] (waiting...)
    每个请求独占一个线程，阻塞式处理，超出线程数则拒绝请求。这种模式不适合高并发，容易导致性能瓶颈。

    Netty 采用的第三种模式，即主从 Reactor 多线程模式，最为高效，适合高并发的网络应用程序。