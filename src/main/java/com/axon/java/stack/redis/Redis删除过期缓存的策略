Redis 删除过期缓存的策略主要有以下三种方式：

1. 定时删除（Timed Deletion）

Redis 会为每个设置了过期时间的键创建一个定时器，一旦键过期，定时器就会触发并立即删除这个键。虽然这种方式可以保证过期的键被及时删除，但会对性能有较大影响，尤其是在大量键过期的情况下，因为 Redis 需要维护大量的定时器。

优点：

	•	过期键可以精确地在过期时间点被删除。

缺点：

	•	对性能消耗大，尤其是在有大量过期键时，创建和维护定时任务会占用资源。

2. 惰性删除（Lazy Deletion）

Redis 不会主动删除过期键，只有当客户端尝试访问某个键时，Redis 会检查这个键是否已经过期，如果过期则立即删除并返回空值。

优点：

	•	对性能影响小，只有在访问时才检查和删除。

缺点：

	•	如果过期键不被访问，会一直占用内存。

3. 定期删除（Periodic Deletion）

Redis 定期（每隔一段时间）对设置了过期时间的键进行扫描，随机抽取一部分键，检查它们是否过期，如果发现已经过期则删除。Redis 会在内存和性能之间进行平衡，每次只删除一小部分过期键，以防止影响正常请求的响应时间。

优点：

	•	通过定期扫描，减少过期键占用的内存。

缺点：

	•	不能保证过期键在过期时间点被删除，可能会延迟删除。

三种策略的结合：

Redis 实际上是这三种方式的组合：

	•	惰性删除 确保不必要的键不会占用内存，但只有在键被访问时才会触发。
	•	定期删除 则在后台定时清理一些过期键，以减轻内存负担。
	•	定时删除 因性能问题通常不常用，Redis 主要依赖惰性删除和定期删除的组合来保持性能和内存使用的平衡。

这种组合策略能够保证 Redis 既可以及时清理大多数过期数据，同时又不会对性能产生过大的影响。



Redis 中三种过期缓存删除策略的底层使用了不同的算法来平衡性能和资源占用。下面分别介绍它们的底层算法：

1. 定时删除（Timed Deletion）

底层算法：定时器算法

Redis 为每个设置了过期时间的键创建一个定时器（timer）。定时器会在键的过期时间到达时被触发，并执行删除操作。这个过程需要 Redis 对大量键进行时间管理，因此可能会涉及二叉堆、红黑树等数据结构来维护键的到期时间顺序，以确保能有效找到最近需要删除的键。

	•	优势：精准控制过期键的删除时间。
	•	劣势：对性能影响较大，特别是当大量键有过期时间时，维护和触发定时器的开销很大。

2. 惰性删除（Lazy Deletion）

底层算法：O(1) 检查

惰性删除的底层逻辑相对简单。当客户端访问某个键时，Redis 检查该键是否过期，这个操作的时间复杂度为 O(1)，即常数时间复杂度。如果该键已经过期，Redis 会立即删除它，然后返回空值。

	•	优势：只有在访问时才进行检查，节省了额外的计算资源。
	•	劣势：如果一个键从不过期或不被访问，它会一直占用内存。

3. 定期删除（Periodic Deletion）

底层算法：随机采样 + 过期扫描

Redis 定期扫描一部分设置了过期时间的键。该扫描过程不是遍历所有键，而是通过随机采样算法从过期集合中随机选择一些键来检查它们是否过期。通常，Redis 会在每次扫描中进行多个采样操作，找到过期的键并删除。

	•	优势：通过随机采样避免了遍历所有键的高开销，保持了删除操作的性能平衡。
	•	劣势：可能无法及时删除所有过期键，过期键的删除可能会有延迟。

总结

	•	定时删除：使用定时器或与时间管理相关的数据结构（如二叉堆或红黑树）来触发精确的删除操作。
	•	惰性删除：在访问键时进行简单的过期检查，时间复杂度为 O(1)，不依赖复杂的数据结构。
	•	定期删除：通过随机采样来扫描和删除部分过期键，使用的是随机抽样算法，并避免全量扫描。

这三种策略各有优缺点，通过混合使用可以在内存效率和性能上实现平衡。