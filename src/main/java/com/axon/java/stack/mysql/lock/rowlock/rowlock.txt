场景案例
  有会话session1  和 会话session2 两个分别同时操作数据库test_innodb_lock表，设置手动提交事务，查看不提交和提交后情况。 使用InnoDB引擎

  设置手动提交事务命令， set autocommit=0;
  分别做查询和 增删改操作

  select * from  test_innodb_lock where a='4'

1>.操作增删改操作

     session1                                                                                                       session2
  当前会话，针对条件 a='4'做更新操作，更新成功，但未手动commit                                                  当前会话，针对条件 a='4'做更新操作， 会被阻塞，无法更新，只有等session1 提交后才能更新



2>.操作增删改操作，查看结果值

     session1                                                                                                           session2
  当前会话，针对条件 a='4'做更新操作，更新成功，但未手动commit，可以查看到当前的最新结果                            session1 未提交时，查看的结果值仍然是旧的值，但session1提交后，当前会话也要提交一次，才能查询到最新的结果值




总结： innoDB 使用了行级别的锁，也使用了事务。对相同一条记录，同时写时，则会触发写锁，写锁时独占，所以其他的会话写时会被阻塞，但读时候，不会被阻塞，只不过是读取旧的值。




