
一、MySql 安装相关命令

1.查询mysql的安装状态
ps -ef | grep  mysql
ps -aux | grep mysql

区别总结：
	•	输出格式: ps -ef 提供更详细的信息，如 PPID、UID、TTY 等，而 ps -aux 更侧重于显示用户相关的资源使用信息（如 CPU、内存使用率）。
	•	适用场景:
	•	使用 ps -ef 时，适合查看详细的进程信息和进程之间的关系。
	•	使用 ps -aux 时，适合查看进程的资源使用情况和进程状态（如 Ssl、Ss 等）。

2.服务器上登录Mysql
mysql -u root -p

3.安装mysql
    下载特定安装包进行调整

4.mysql的字符集调整


5.mysql 文件包含哪些？
    5.1>frm 文件用于存放表结构
    5.2>myd 文件存放表数据
    5.3>myi 文件存放的表索引

6.mysql分层
    6.1>连接层
        功能: 连接层是 MySQL 的最外层，负责处理客户端的连接请求。这个层次主要负责管理和维护客户端连接，并进行身份验证、权限检查以及跟踪连接的状态。

        	•	连接管理: 处理来自客户端的连接请求，如 TCP/IP 连接、Unix Socket 连接等。
        	•	身份验证: 确认用户的身份，确保只有有权访问的用户才能连接到数据库。
        	•	连接缓存: 连接的缓存和管理，减少频繁建立和断开连接的开销。

        举例:
        当一个应用程序尝试连接到 MySQL 数据库时，连接层会处理这个请求，验证用户身份，分配一个连接线程，并为后续的查询做好准备。

    6.2>服务层
        功能: 服务层是 MySQL 的核心部分，负责处理 SQL 查询，并执行包括解析、优化、缓存、和执行在内的所有逻辑操作。

        	•	SQL 解析: 解析 SQL 查询，将其转换为 MySQL 可以理解的格式，检查语法和表的名称。
        	•	查询优化: 对查询进行优化，生成执行计划，以找到最优的执行路径。这包括索引的选择、查询重写等。
        	•	查询缓存: 检查查询是否已经缓存，如果是则直接返回缓存结果，减少数据库操作的开销。
        	•	事务管理: 管理事务的开始、提交、回滚，并确保 ACID（原子性、一致性、隔离性、持久性）属性。

        举例:
        当客户端发送一个 SELECT 查询时，服务层负责解析这个查询、优化执行计划、执行查询，并返回结果。
    6.3>引擎层
        功能: 引擎层与存储引擎密切相关，负责实际数据的读写操作。MySQL 的存储引擎层是模块化的，这意味着可以根据需求选择不同的存储引擎，如 InnoDB、MyISAM、Memory 等。

        	•	存储引擎接口: MySQL 提供了一种接口，允许不同的存储引擎进行数据的存储和读取操作。
        	•	引擎选择: 不同的存储引擎有不同的特性和性能特点，例如 InnoDB 支持事务和外键，而 MyISAM 则更适合只读应用。

        举例:
        当 MySQL 要执行一个 INSERT 操作时，服务层会调用引擎层的接口，将数据写入到指定的存储引擎中（例如 InnoDB）。

    6.4>储存层
        功能: 存储层是 MySQL 的最底层，直接与操作系统的文件系统进行交互，负责物理数据的存储和管理。

        	•	数据存储: 负责将数据存储到磁盘上的文件或其他介质中。这包括数据文件、索引文件、日志文件等。
        	•	文件管理: 管理数据的组织形式，决定如何在磁盘上布局数据和索引。
        	•	数据恢复: 在崩溃后，从存储的日志或数据文件中恢复数据，确保数据的持久性。

        举例:
        当需要将数据写入磁盘时，存储层负责将数据块写入物理存储设备，并管理磁盘空间的分配。
    总结

    	•	连接层: 处理客户端连接请求，验证用户身份，管理连接。
    	•	服务层: 处理 SQL 查询的解析、优化、执行，管理事务和缓存。
    	•	引擎层: 提供对存储引擎的接口，实现数据的读写操作。
    	•	存储层: 与操作系统的文件系统交互，管理物理数据存储。

二、mysql引擎

1. 查询mysql 引擎命令
   1.1>查询所有支持的存储引擎:
        SHOW ENGINES;
       该命令会返回一个包含所有支持的存储引擎的列表，以及每个存储引擎的状态和描述。输出中的一些关键列包括：

        •	Engine: 存储引擎的名称。
        •	Support: 存储引擎是否被支持（YES、NO、DISABLED）。
        •	Comment: 对存储引擎的描述。
        •	Transactions: 是否支持事务（YES、NO）。

   1.2>查看默认存储引擎:
        SHOW VARIABLES LIKE 'default_storage_engine';
        该命令会返回 MySQL 的默认存储引擎。通常默认引擎是 InnoDB，但可以根据需求在配置文件中修改。

   1.3>查询当前数据库表使用的存储引擎:
        SHOW TABLE STATUS WHERE Name = 'your_table_name';
        该命令会返回 MySQL 的默认存储引擎。通常默认引擎是 InnoDB，但可以根据需求在配置文件中修改。
   1.4> 更改表的存储引擎
        ALTER TABLE your_table_name ENGINE = InnoDB;
        这条命令会将 your_table_name 的存储引擎更改为 InnoDB。

2.myISAM 和InnoDB 的引擎的区别
    2.1> 事务支持
    	•	InnoDB: 支持事务（Transaction），遵循 ACID（原子性、一致性、隔离性、持久性）原则。通过 COMMIT、ROLLBACK、SAVEPOINT 等命令，可以进行事务操作，确保数据的完整性。
    	•	MyISAM: 不支持事务。如果应用程序需要进行大量的事务处理（如银行、财务应用），则 MyISAM 不适用。
    2.2> 外键支持
    	•	InnoDB: 支持外键约束，可以强制执行表与表之间的引用完整性，确保数据的一致性。
    	•	MyISAM: 不支持外键约束，表与表之间的引用完整性需要应用层自己管理。
    2.3> 锁机制
    	•	InnoDB: 使用行级锁（Row-level locking），在处理大并发量的写操作时，行级锁的冲突较少，适合需要频繁读写的应用。
    	•	MyISAM: 使用表级锁（Table-level locking），在进行写操作时会锁住整个表。因此，当有大量读写操作时，MyISAM 的性能可能会受到影响。
    2.4> 全文索引
    	•	MyISAM: 支持全文索引（Full-text search），适合需要进行全文搜索的应用场景（MySQL 5.6 版本后 InnoDB 也支持全文索引）。
    	•	InnoDB: 在 MySQL 5.6 版本之前，不支持全文索引。如果需要全文检索功能，需要使用 MyISAM 或者升级 MySQL 版本。
    2.5> 数据存储
    	•	InnoDB: InnoDB 会把表的数据和索引存储在一起，采用聚簇索引（Clustered Index），可以更快地根据主键检索数据。每张表会生成一个 .ibd 文件来存储数据和索引。
    	•	MyISAM: MyISAM 会将表的数据和索引分开存储，数据存储在 .MYD 文件中，索引存储在 .MYI 文件中。这样在表的大小和文件管理方面更为简单，但对大数据量的处理能力较弱。
    2.6> 崩溃恢复
    	•	InnoDB: 具有自动崩溃恢复功能，通过重做日志（redo logs）和撤销日志（undo logs），可以在崩溃后恢复未完成的事务。
    	•	MyISAM: 不具备自动崩溃恢复功能。如果 MyISAM 表在写入时崩溃，可能会导致数据损坏，需要手动修复（使用 myisamchk 工具）。
    2.7> 表的大小限制
    	•	InnoDB: 默认情况下，InnoDB 表的大小可以非常大，支持最大 64TB 的表空间（可配置）。
    	•	MyISAM: MyISAM 表的默认大小限制为 256TB。
    2.8> 性能
    	•	InnoDB: 在处理高并发、大量写入操作时表现更好，尤其是需要支持事务的应用。
    	•	MyISAM: 适合以读为主的应用，由于其表级锁机制，在高读操作量下的查询速度非常快，但在高并发写操作下可能会表现出瓶颈。
    2.9> 存储空间
    	•	InnoDB: 由于支持事务和行级锁机制，InnoDB 存储的数据通常比 MyISAM 多（需要额外的存储空间来管理事务和锁信息）。
    	•	MyISAM: 通常比 InnoDB 节省存储空间，适合不需要事务且空间受限的场景。
    2.10> 自增字段的处理
    	•	InnoDB: 自增字段在每次插入时都会自动加一，且自增值只在提交（commit）时保存。
    	•	MyISAM: 自增字段直接保存，因此更快，但没有事务安全保障。

    总结
    	•	选择 InnoDB：如果应用需要事务支持、外键约束、行级锁、以及自动崩溃恢复，那么 InnoDB 是更好的选择，特别是在高并发、大量写操作的场景中。
    	•	选择 MyISAM：如果应用主要以读操作为主，不需要事务支持，并且需要使用全文索引，那么 MyISAM 可能更适合。


三、mysql 性能优化

1.一条select 语句的执行顺序是什么？

    1.	FROM 子句
	    •	首先执行的是 FROM 子句，确定查询的数据来源，也就是需要查询的表或视图。
	    •	如果有 JOIN 操作，这时候会先处理连接操作。
	2.	WHERE 子句
	    •	WHERE 子句在 FROM 之后执行，用来过滤符合条件的记录。此步骤仅返回满足条件的行。
	3.	GROUP BY 子句
	    •	GROUP BY 子句将符合条件的行按照指定的列进行分组，并对每个组应用聚合函数（如 SUM()、COUNT() 等）。
	4.	HAVING 子句
	    •	HAVING 子句用于对 GROUP BY 的分组结果进行进一步的过滤。它与 WHERE 类似，但 WHERE 是在分组之前过滤，而 HAVING 是在分组之后过滤。
	5.	SELECT 子句
	    •	执行 SELECT 子句，选择需要返回的列或表达式。此时会应用选择的列、计算表达式、执行聚合函数等操作。
	6.	DISTINCT 子句
	    •	如果使用了 DISTINCT，会在 SELECT 执行之后去除重复的行。
	7.	ORDER BY 子句
	    •	ORDER BY 子句按照指定的列对查询结果进行排序。
	8.	LIMIT 子句
	    •	LIMIT 子句用于限制返回的行数。在排序完成后，返回指定数量的记录。

    SELECT DISTINCT column1, SUM(column2)
    FROM table_name
    WHERE condition
    GROUP BY column1
    HAVING SUM(column2) > 100
    ORDER BY column1
    LIMIT 10;

    其执行顺序为：
    	1.	FROM: 从 table_name 表中选择数据。
    	2.	WHERE: 筛选符合 condition 的行。
    	3.	GROUP BY: 对 column1 进行分组。
    	4.	HAVING: 筛选聚合结果，保留 SUM(column2) > 100 的分组。
    	5.	SELECT: 选择 column1 和 SUM(column2) 列。
    	6.	DISTINCT: 去除 column1 和 SUM(column2) 列的重复结果。
    	7.	ORDER BY: 对结果按照 column1 排序。
    	8.	LIMIT: 返回前 10 行结果。


2. 什么是索引？
    索引是数据库中一种用于快速查找数据的特殊数据结构。通过使用索引，可以大大加快查询速度，减少磁盘 I/O 操作。索引在数据库表的某些列上创建，目的是为了提高查询操作（如 SELECT 语句）的效率，尤其是在数据量较大的情况下。
    索引的基本概念

    	•	索引的作用：索引就像一本书的目录，通过目录可以快速找到某个章节的内容，而不必从头开始逐页查找。对于数据库来说，索引可以帮助查询语句快速定位到存储在磁盘上的数据。
    	•	索引的结构：索引通常以树形结构（如 B+ 树）或哈希表的形式存储，具体结构取决于所使用的数据库引擎。例如，InnoDB 引擎的索引通常是基于 B+ 树的。
    常见类型的索引

    	1.	主键索引（Primary Key Index）：
    	•	自动为表的主键字段创建的唯一索引，每个表只能有一个主键索引。主键索引不仅保证每一行记录的唯一性，还可以用于快速查询。
    	2.	唯一索引（Unique Index）：
    	•	唯一索引确保索引列中的值是唯一的，可以在列上有多个唯一索引，不同于主键索引的是，唯一索引允许有 NULL 值。
    	3.	普通索引（Normal Index）：
    	•	普通索引用于加快数据的查找，没有唯一性的约束，可以在表的一个或多个列上创建普通索引。
    	4.	全文索引（Full-text Index）：
    	•	用于对文本字段进行全文搜索，通常用于处理大量文本数据，例如搜索引擎。
    	5.	组合索引（Composite Index）：
    	•	组合索引是对表的多个列进行联合索引，这些列被作为一个整体进行索引操作，可以提高多个列的查询效率。

    索引的优点

    	•	加速数据检索：索引可以大幅提高 SELECT 查询的执行速度，尤其是在大数据量的表中。
    	•	加速排序：索引可以帮助数据库快速排序数据，而不必在执行查询时对整个数据集进行排序。
    	•	提高分组和聚合的性能：通过索引进行分组和聚合操作比对全表数据扫描的方式更高效。

    索引的缺点

    	•	占用空间：索引需要占用额外的存储空间，尤其是对大表来说，索引占用的空间可能会非常大。
    	•	影响写操作性能：每当对表中的数据进行 INSERT、UPDATE 或 DELETE 操作时，数据库不仅要修改数据，还需要更新相应的索引。这会导致写操作的性能下降。


3.通常都有哪些因素会影响mysql 中select语句的查询性能？
    1.	索引的使用：索引可以大幅提升查询速度，但不合理的索引设计或缺乏索引会导致性能下降。
    2.	查询的复杂性：复杂的查询语句（如带有多个表连接、子查询、大量聚合操作等）会增加数据库的计算开销，影响查询性能。
    3.	数据量：表中的数据量越大，查询所需的时间就越长。尤其是在没有索引的情况下，MySQL 需要对表中的每一行进行扫描，性能下降更为显著。
    4.	服务器硬件：包括 CPU、内存、磁盘 I/O 等硬件条件，直接影响数据库的处理能力。
    5.	数据库配置：MySQL 的配置参数如 innodb_buffer_pool_size、query_cache_size 等会影响查询的执行效率。
    6.	表结构设计：不合理的表结构设计（如过多的列、冗余数据、未归一化的设计）会导致查询效率低下。
    7.	锁的争用：在高并发环境下，表锁或行锁的争用会导致查询等待，从而影响查询性能。
    8.	网络延迟：如果数据库和应用服务器不在同一台机器上，网络延迟也可能影响查询速度。
    9.	使用不当的 SQL 语句：例如在 WHERE 子句中使用非索引列或不必要的 ORDER BY、GROUP BY 等操作，会导致全表扫描，影响查询性能。
    10.	MySQL 版本及存储引擎：不同版本的 MySQL 及不同的存储引擎（如 InnoDB、MyISAM）在性能表现上有所不同。

4.在那些情况下需要创建索引？ 那些情况下不需要创建索引？
    需要创建索引的情况：

    	1.	经常查询的列：
    	    •	对于经常出现在 WHERE、JOIN、GROUP BY、ORDER BY 语句中的列，需要创建索引来加速查询。例如，用户常常通过某个字段（如 user_id 或 email）来查找记录，此时在该字段上创建索引可以大幅提高查询速度。
    	2.	唯一性约束：
    	    •	对于要求唯一值的列（如主键 PRIMARY KEY 或唯一索引 UNIQUE），需要创建索引来强制唯一性约束并加速查询。
    	3.	外键：
    	    •	外键关系字段通常也是连接操作的重要字段，因此在外键列上创建索引可以提高 JOIN 操作的性能。
    	4.	需要排序的列：
    	    •	对经常需要排序的列（如 ORDER BY），创建索引可以避免 MySQL 进行全表扫描，从而提高排序的效率。
    	5.	部分查询列：
    	    •	如果查询时只查询部分列，而这些列都可以从索引中获得数据（覆盖索引），则在这些列上创建索引可以显著提高查询性能。

    不需要创建索引的情况：

    	1.	低选择性列：
    	    •	对于选择性很低的列（如性别、布尔值等二值列），即使创建了索引，MySQL 也很难利用索引提高查询性能。因为这些列的重复值太多，查询时可能依然会进行大量的数据扫描。
    	2.	经常更新的列：
    	    •	对于频繁更新的列，不建议创建索引。因为每次更新操作都需要维护索引，增加了系统的负担，影响写入性能。
    	3.	小表或数据量很少的表：
    	    •	对于数据量非常少的表，创建索引的作用不大，因为 MySQL 可以很快地扫描整个表而不需要索引。
    	4.	频繁插入操作的表：
    	    •	对于插入操作非常频繁的表，索引的维护成本较高。如果查询的性能要求不高，可以考虑不创建或少创建索引，以提高插入速度。
    	5.	临时表：
    	    •	临时表通常只在短时间内存在，并且其数据量通常较小，创建索引的成本可能会超过查询带来的性能提升。
    	6.	带有大量重复值的列：
    	    •	如果列中的值大部分都相同，索引的效果会很差，因为索引查找仍然需要扫描大量的行。


5.mysql的索引结构都有哪些？
    1.	B-Tree 索引：
    	•	默认索引类型：InnoDB 和 MyISAM 存储引擎使用的默认索引类型。
    	•	特点：B-Tree 索引是一种自平衡的树数据结构，能够保持数据有序，并支持高效的范围查询、排序等操作。InnoDB 使用的是聚簇索引，表数据存储在 B-Tree 的叶子节点中。
    2.	哈希索引：
    	•	MyISAM 和 Memory 存储引擎的特有索引类型。
    	•	特点：哈希索引使用哈希表来存储索引数据，适用于等值查询，但不支持范围查询。因为哈希表的查找速度快，所以在精确匹配的查询中表现优异。
    3.	全文索引：
    	•	适用于 MyISAM 和 InnoDB 存储引擎。
    	•	特点：全文索引用于进行文本搜索，可以进行更复杂的查询，如单词匹配和自然语言搜索。MySQL 5.6 及以后版本，InnoDB 引擎也开始支持全文索引。
    4.	空间索引：
    	•	适用于 MyISAM 和 InnoDB 存储引擎。
    	•	特点：空间索引用于地理空间数据的查询，如位置坐标。支持 R-Tree 结构，能够高效地进行空间范围查询。
    5.	前缀索引：
    	•	InnoDB 和 MyISAM 支持的索引类型。
    	•	特点：对于字符串列，可以只索引前缀的一部分，以节省空间。适用于长文本列的索引，但只对前缀部分进行索引。
    6.	组合索引：
    	•	InnoDB 和 MyISAM 支持的索引类型。
    	•	特点：将多个列组合成一个索引，适用于多列的查询条件，可以优化涉及多个列的查询性能


6.索引优化参数说明
    1. id

    	•	描述：查询的唯一标识符。id 相同的查询步骤可以被认为是并行执行的，不同的 id 值之间按顺序执行。
    	•	取值：
    	•	同一组 id：表示这些步骤在同一级别。
    	•	id 数值越大：优先级越高，执行顺序越早。

    2. select_type

    	•	描述：查询的类型，表示当前行是简单查询、子查询还是联合查询的一部分。
    	•	常见取值：
    	•	SIMPLE：简单查询，不包含子查询或联合查询。
    	•	PRIMARY：最外层的查询。
    	•	UNION：联合查询中的第二个或后续的 SELECT 语句。
    	•	SUBQUERY：子查询中的 SELECT 语句。
    	•	DERIVED：派生表（临时表），通常是子查询中的 SELECT。

    3. table

    	•	描述：当前查询操作的表名或别名。

    4. partitions

    	•	描述：如果表是分区表，显示查询使用了哪些分区。

    5. type

    	•	描述：访问类型，表示 MySQL 如何查找满足查询条件的行。
    	•	从优到劣的顺序：
    	•	system：表只有一行（等同于系统表），是最优的查询。
    	•	const：表最多只有一行匹配的行（例如主键或唯一索引）。
    	•	eq_ref：对于每一行结合的结果，都会查找匹配的行，通常用于多表查询的索引扫描。
    	•	ref：非唯一索引扫描，返回匹配某一单个值的所有行。
    	•	range：范围扫描，通常用于使用索引的 BETWEEN、<、> 等操作。
    	•	index：全索引扫描，与 ALL 类似，但只扫描索引树。
    	•	ALL：全表扫描，是最慢的查询。

    6. possible_keys

    	•	描述：MySQL 考虑用于查询的索引列表。

    7. key

    	•	描述：实际使用的索引。如果是 NULL，则没有使用索引。

    8. key_len

    	•	描述：使用索引的长度，表示 MySQL 实际用到的索引字节数。这个值越短，查询效率越高。

    9. ref

    	•	描述：表示索引列与表中字段的比较方式。
    	•	常见取值：
    	•	const：用于常数比较。
    	•	字段名：表示使用该字段的值来与索引匹配。

    10. rows

    	•	描述：MySQL 估算要读取的行数，这是一个估计值，显示多少行数据会被扫描。

    11. filtered

    	•	描述：显示条件过滤器的百分比，表示满足条件的行的百分比。值越高，表示越多的行满足查询条件。

    12. Extra

    	•	描述：其他补充信息，说明 MySQL 在执行查询时做了哪些额外的操作。
    	•	常见取值：
    	•	Using index：表示查询只使用索引来检索数据，而没有访问表的实际数据行。
    	•	Using where：表明 MySQL 在索引过滤之后，还应用了 WHERE 条件过滤。
    	•	Using temporary：使用临时表来存储中间结果，通常出现在 GROUP BY 或 ORDER BY 查询中。
    	•	Using filesort：MySQL 使用了外部排序而不是通过索引进行排序，通常出现在 ORDER BY 查询中。

    当 EXPLAIN 的 Extra 列中同时出现了 Using where 和 Using index 时，这表示 MySQL 在执行查询时进行了以下操作：

    	1.	Using index：
    	•	表示 MySQL 仅通过索引扫描就可以满足查询，不需要访问表的实际数据行。这通常意味着查询的所有需要的数据都可以从索引中获取。
    	•	当索引覆盖了查询中所需的所有字段时（即所谓的“覆盖索引”或“索引覆盖”），MySQL 就可以直接从索引中返回数据，而无需读取表的行数据。这种方式通常比直接扫描数据行更快。
    	2.	Using where：
    	•	表示 MySQL 在通过索引扫描后，还应用了 WHERE 子句中的过滤条件。
    	•	即使索引已经提供了部分过滤条件，MySQL 仍需要进一步过滤索引扫描结果，以符合 WHERE 子句中的其他条件。

    总结

    	•	Using index：意味着 MySQL 使用了覆盖索引，查询所需的数据都从索引中获取，不需要额外访问表的实际数据行。
    	•	Using where：意味着 MySQL 在使用索引扫描的基础上，还应用了 WHERE 子句来进一步过滤结果。

    当这两个信息同时出现时，表示 MySQL 使用了一个索引来扫描数据，并且在扫描过程中还应用了 WHERE 子句中的条件，而无需访问表中的实际行数据。这种情况通常表示查询性能较好，因为它避免了对表的实际行数据的读取。


7.索引优化策略
    1.全值匹配我最爱
    2.最佳左前缀法则
    3.不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效，从而转向全表扫描
    4.存储引用不能使用索引中范围条件右边的列。
    5.尽量使用覆盖索引（只访问索引的查询（索引和查询列一致），减少select * 的查询）
    6.mysql在使用不等于（!= 或<>）的时候无法使用索引会导致全表扫描
    7.is null , is  not null 不能使用索引
    8.like以通配符开头（%abc）mysql索引会失效，导致全表扫描
    9.字符串不加单引号会导致索引失效
    10.少用or 用它链接时索引会失效。

